# TuranEngine
A game engine I was working in last summer, this winter break and will continue this summer. First development target is the Renderer and UI, then Game Object and ECS-Fiber Task systems. Only tested for Windows, but I think it is easy to port to other platforms using CMake or Premake. If you want to run the TuranEditor without compiling, open bin/TuranEditor/TuranEditor.exe.

# Refactoring:
This refactoring was a need because I had lots of wrong decisions that I can't do on my own on rendering architecture. So I just switched to the new architecture that I thought a little bit wider -by knowing my own capabilities- and also I wrote and will write some helping systems such as Logging, TokenSystem etc. So the changes are in below as much as I can remember

1) Logging system added to TuranAPI and have 5 types of logging. Crashing, HandledError, Warning, Status and Not Coded Path. There are 4 types of log files: Not Coded Paths, Errors, Warnings and All Logs. All of the logs are written to text files when a TuranAPI::LOG_CRASHING, a TuranAPI::LOG_NOTCODED(string, true) or application closed in IMGUI because logging per frame is costly operation with lots of log. And also TURAN_DEBUGGING macro is defined to build something with debugging purpose without going to Debugging mode of Visual Studio because my computer can't start the app in Debugging mode in 3 minutes.
2) Rendering Architecture was hard-coded and there was no resource handling and it was impossible to do so because I didn't understand data management. Now I'm sure that I have a system idea that will work as I aimed at the beginning of the project. I didn't code it yet but the system will be like that: There will be a Token System as I described below. Each frame, we will bind all RenderGraphs one by one to the GFX_API specific coded RenderGraph_Manager. Each RenderGraph will have  a Scene to render (A Scene Editor and A Object Viewer can have different rendering paths that way). RenderGraph_Manager will have all access on Scene and RenderGraph. In RenderGraph, each RenderNode will have lots of Tokens to define inputs. RenderGraph_Manager will search for these Tokens in resources. Each RenderNode will have a unique Token and RenderGraph_Manager first search for all Draw Pass nodes. It will grab the DrawPass's Token and its Input Scene Component Tokens. Then it will search all of the Scene for these Tokens and generate RenderCommand for each matching Scene Component like this RenderCommand::Draw_StaticMesh(DrawPassTOKEN, StaticModel_Component->GetMesh(i)->GetMaterial_Instance(), StaticModel_Component->GetMesh(i)->Get_MeshData()); . Then, it will go to "Dependency Creation" progress. For example, a Compute Pass can have a input render target. Manager will search for a matching RenderTarget with Token specified in RenderNode. For Draw Pass, it will search in all of the RenderCommands that have same DrawPass Token and will read dependencies of each Scene Component (Because a material instance may use a RenderTarget of a different Draw Pass, it will search each material instance's and model data's dependencies). While reading the dependencies of each Scene Component, it will sort them to avoid unnecessary API calls and will create APICommands. When all of the RenderNodes' dependencies are created, Manager will resort all of the RenderNodes and created barriers, transient resources etc. Then according to the dependencies, it will run each Render Node and call each APICommand's Run function. APICommand will be used to store data to call a GL API function when the time comes, RenderCommand will be used to only store necessary informations to detect dependencies of a resoure/component.
3) Token System: It will be a serializing supported key system. TokenSystem is going to have a map that stores a string for each 64 bit integer. A Token itself is a 64 bit integer, but TokenSystem will store a string for each Token's to define the Token easier. TokenSystem will only have one function, GetToken(string). First GetToken will search for an matching string and if there is, according 64 bit integer will be returned. If there isn't, an 64 bit integer will be created, saved to TokenList.enginecont and the integer is returned! When TuranEngine starts, it will load TokenList.enginecont. But this blocks me using a Token before starting the TuranEngine, but all of the systems should start after TuranEngine anyway.
4) I was having lots of trouble with Resource system because there were some empty created Resources etc. Now I have a Resource Verification progress for each Resource.
5) Instead of OpenGL3, I switched to OpenGL4 because OpenGL3 has lots of unnecessary limitations that would make RenderGraph architecture much much more complex and OpenGL4 has lots of feature set current devices (Mobile, Desktop, Console) have. Some very basic limitations are: Stencil Texture isn't supported, so Compute and Draw Passes would have a big limitation on devices would mostly not used anymore. It is still possible to create a OpenGL3 backend but programmer would need to create lots of limitations to RenderGraph. I want to create a RenderGraph UI in Editor, so programmer also would be responsible for creating limitations to RenderGraph UI but RenderGraph UI is far beyond my capabilities for now.

# How to define a RenderNode's dependencies: 
Render Node will call a function like Create_Input(Render_Resource(GFX::RenderTarget, RenderTargetToken)); in Resources() or it will have a vector of Scene_Resource and each resource will be defined in constructor like Scene_Resources.push_back(Scene_Resource(GFX::INPUT, GFX::RenderTarget, TOKEN_NAME)); I don't know which is the better way.