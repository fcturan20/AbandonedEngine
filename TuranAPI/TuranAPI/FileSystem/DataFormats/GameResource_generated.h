// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAMERESOURCE_GAMECONTENT_H_
#define FLATBUFFERS_GENERATED_GAMERESOURCE_GAMECONTENT_H_

#include "flatbuffers/flatbuffers.h"

namespace GameContent {

struct Vec3;

struct Vec2;

struct Vec4;

struct Mat4x4;

struct TEXTURE;

struct UNIFORM_UINT32;

struct UNIFORM_INT32;

struct UNIFORM_FLOAT;

struct UNIFORM_VEC2;

struct UNIFORM_VEC3;

struct UNIFORM_VEC4;

struct UNIFORM_MAT4x4;

struct UNIFORM_TEXTURE2D;

struct MATERIAL_INSTANCE_UNIFORM_TABLE;

struct MATERIAL_TYPE;

struct MATERIAL_INSTANCE;

struct MESH;

struct STATIC_MODEL;

struct StaticModel_ComponentTable;

struct Camera_ComponentTable;

struct GameComponent;

struct SCENE;

struct File;

struct FileList;

struct Resource;

enum TEXTURE_DIMENSION {
  TEXTURE_DIMENSION_TEXTURE_2D = 0,
  TEXTURE_DIMENSION_MIN = TEXTURE_DIMENSION_TEXTURE_2D,
  TEXTURE_DIMENSION_MAX = TEXTURE_DIMENSION_TEXTURE_2D
};

inline const TEXTURE_DIMENSION (&EnumValuesTEXTURE_DIMENSION())[1] {
  static const TEXTURE_DIMENSION values[] = {
    TEXTURE_DIMENSION_TEXTURE_2D
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_DIMENSION() {
  static const char * const names[2] = {
    "TEXTURE_2D",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_DIMENSION(TEXTURE_DIMENSION e) {
  if (e < TEXTURE_DIMENSION_TEXTURE_2D || e > TEXTURE_DIMENSION_TEXTURE_2D) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_DIMENSION()[index];
}

enum TEXTURE_CHANNELs {
  TEXTURE_CHANNELs_TEXTURE_RGB = 0,
  TEXTURE_CHANNELs_TEXTURE_RGBA = 1,
  TEXTURE_CHANNELs_TEXTURE_DEPTH = 2,
  TEXTURE_CHANNELs_MIN = TEXTURE_CHANNELs_TEXTURE_RGB,
  TEXTURE_CHANNELs_MAX = TEXTURE_CHANNELs_TEXTURE_DEPTH
};

inline const TEXTURE_CHANNELs (&EnumValuesTEXTURE_CHANNELs())[3] {
  static const TEXTURE_CHANNELs values[] = {
    TEXTURE_CHANNELs_TEXTURE_RGB,
    TEXTURE_CHANNELs_TEXTURE_RGBA,
    TEXTURE_CHANNELs_TEXTURE_DEPTH
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_CHANNELs() {
  static const char * const names[4] = {
    "TEXTURE_RGB",
    "TEXTURE_RGBA",
    "TEXTURE_DEPTH",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_CHANNELs(TEXTURE_CHANNELs e) {
  if (e < TEXTURE_CHANNELs_TEXTURE_RGB || e > TEXTURE_CHANNELs_TEXTURE_DEPTH) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_CHANNELs()[index];
}

enum TEXTURE_MIPMAP_FILTERING {
  TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP = 0,
  TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_2MIP = 1,
  TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_1MIP = 2,
  TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_2MIP = 3,
  TEXTURE_MIPMAP_FILTERING_MIN = TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP,
  TEXTURE_MIPMAP_FILTERING_MAX = TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_2MIP
};

inline const TEXTURE_MIPMAP_FILTERING (&EnumValuesTEXTURE_MIPMAP_FILTERING())[4] {
  static const TEXTURE_MIPMAP_FILTERING values[] = {
    TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP,
    TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_2MIP,
    TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_1MIP,
    TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_2MIP
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_MIPMAP_FILTERING() {
  static const char * const names[5] = {
    "LINEAR_FROM_1MIP",
    "LINEAR_FROM_2MIP",
    "NEAREST_FROM_1MIP",
    "NEAREST_FROM_2MIP",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_MIPMAP_FILTERING(TEXTURE_MIPMAP_FILTERING e) {
  if (e < TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP || e > TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_2MIP) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_MIPMAP_FILTERING()[index];
}

enum TEXTURE_WRAPPING {
  TEXTURE_WRAPPING_REPEAT = 0,
  TEXTURE_WRAPPING_MIRRORED_REPEAT = 1,
  TEXTURE_WRAPPING_CLAMP_TO_EDGE = 2,
  TEXTURE_WRAPPING_MIN = TEXTURE_WRAPPING_REPEAT,
  TEXTURE_WRAPPING_MAX = TEXTURE_WRAPPING_CLAMP_TO_EDGE
};

inline const TEXTURE_WRAPPING (&EnumValuesTEXTURE_WRAPPING())[3] {
  static const TEXTURE_WRAPPING values[] = {
    TEXTURE_WRAPPING_REPEAT,
    TEXTURE_WRAPPING_MIRRORED_REPEAT,
    TEXTURE_WRAPPING_CLAMP_TO_EDGE
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_WRAPPING() {
  static const char * const names[4] = {
    "REPEAT",
    "MIRRORED_REPEAT",
    "CLAMP_TO_EDGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_WRAPPING(TEXTURE_WRAPPING e) {
  if (e < TEXTURE_WRAPPING_REPEAT || e > TEXTURE_WRAPPING_CLAMP_TO_EDGE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_WRAPPING()[index];
}

enum TEXTURE_VALUETYPE {
  TEXTURE_VALUETYPE_UBYTE8 = 0,
  TEXTURE_VALUETYPE_BYTE8 = 1,
  TEXTURE_VALUETYPE_UINT32 = 2,
  TEXTURE_VALUETYPE_INT32 = 3,
  TEXTURE_VALUETYPE_FLOAT32 = 4,
  TEXTURE_VALUETYPE_MIN = TEXTURE_VALUETYPE_UBYTE8,
  TEXTURE_VALUETYPE_MAX = TEXTURE_VALUETYPE_FLOAT32
};

inline const TEXTURE_VALUETYPE (&EnumValuesTEXTURE_VALUETYPE())[5] {
  static const TEXTURE_VALUETYPE values[] = {
    TEXTURE_VALUETYPE_UBYTE8,
    TEXTURE_VALUETYPE_BYTE8,
    TEXTURE_VALUETYPE_UINT32,
    TEXTURE_VALUETYPE_INT32,
    TEXTURE_VALUETYPE_FLOAT32
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_VALUETYPE() {
  static const char * const names[6] = {
    "UBYTE8",
    "BYTE8",
    "UINT32",
    "INT32",
    "FLOAT32",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_VALUETYPE(TEXTURE_VALUETYPE e) {
  if (e < TEXTURE_VALUETYPE_UBYTE8 || e > TEXTURE_VALUETYPE_FLOAT32) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_VALUETYPE()[index];
}

enum GFX_APIs {
  GFX_APIs_OPENGL3 = 0,
  GFX_APIs_MIN = GFX_APIs_OPENGL3,
  GFX_APIs_MAX = GFX_APIs_OPENGL3
};

inline const GFX_APIs (&EnumValuesGFX_APIs())[1] {
  static const GFX_APIs values[] = {
    GFX_APIs_OPENGL3
  };
  return values;
}

inline const char * const *EnumNamesGFX_APIs() {
  static const char * const names[2] = {
    "OPENGL3",
    nullptr
  };
  return names;
}

inline const char *EnumNameGFX_APIs(GFX_APIs e) {
  if (e < GFX_APIs_OPENGL3 || e > GFX_APIs_OPENGL3) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGFX_APIs()[index];
}

enum MATERIAL_INSTANCE_UNIFORM {
  MATERIAL_INSTANCE_UNIFORM_NONE = 0,
  MATERIAL_INSTANCE_UNIFORM_UINT32 = 1,
  MATERIAL_INSTANCE_UNIFORM_INT32 = 2,
  MATERIAL_INSTANCE_UNIFORM_FLOAT = 3,
  MATERIAL_INSTANCE_UNIFORM_VEC2 = 4,
  MATERIAL_INSTANCE_UNIFORM_VEC3 = 5,
  MATERIAL_INSTANCE_UNIFORM_VEC4 = 6,
  MATERIAL_INSTANCE_UNIFORM_Mat4x4 = 7,
  MATERIAL_INSTANCE_UNIFORM_TEXTURE2D = 8,
  MATERIAL_INSTANCE_UNIFORM_MIN = MATERIAL_INSTANCE_UNIFORM_NONE,
  MATERIAL_INSTANCE_UNIFORM_MAX = MATERIAL_INSTANCE_UNIFORM_TEXTURE2D
};

inline const MATERIAL_INSTANCE_UNIFORM (&EnumValuesMATERIAL_INSTANCE_UNIFORM())[9] {
  static const MATERIAL_INSTANCE_UNIFORM values[] = {
    MATERIAL_INSTANCE_UNIFORM_NONE,
    MATERIAL_INSTANCE_UNIFORM_UINT32,
    MATERIAL_INSTANCE_UNIFORM_INT32,
    MATERIAL_INSTANCE_UNIFORM_FLOAT,
    MATERIAL_INSTANCE_UNIFORM_VEC2,
    MATERIAL_INSTANCE_UNIFORM_VEC3,
    MATERIAL_INSTANCE_UNIFORM_VEC4,
    MATERIAL_INSTANCE_UNIFORM_Mat4x4,
    MATERIAL_INSTANCE_UNIFORM_TEXTURE2D
  };
  return values;
}

inline const char * const *EnumNamesMATERIAL_INSTANCE_UNIFORM() {
  static const char * const names[10] = {
    "NONE",
    "UINT32",
    "INT32",
    "FLOAT",
    "VEC2",
    "VEC3",
    "VEC4",
    "Mat4x4",
    "TEXTURE2D",
    nullptr
  };
  return names;
}

inline const char *EnumNameMATERIAL_INSTANCE_UNIFORM(MATERIAL_INSTANCE_UNIFORM e) {
  if (e < MATERIAL_INSTANCE_UNIFORM_NONE || e > MATERIAL_INSTANCE_UNIFORM_TEXTURE2D) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMATERIAL_INSTANCE_UNIFORM()[index];
}

template<typename T> struct MATERIAL_INSTANCE_UNIFORMTraits {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_NONE;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GameContent::UNIFORM_UINT32> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_UINT32;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GameContent::UNIFORM_INT32> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_INT32;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GameContent::UNIFORM_FLOAT> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_FLOAT;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GameContent::UNIFORM_VEC2> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_VEC2;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GameContent::UNIFORM_VEC3> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_VEC3;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GameContent::UNIFORM_VEC4> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_VEC4;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GameContent::UNIFORM_MAT4x4> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_Mat4x4;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GameContent::UNIFORM_TEXTURE2D> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_TEXTURE2D;
};

bool VerifyMATERIAL_INSTANCE_UNIFORM(flatbuffers::Verifier &verifier, const void *obj, MATERIAL_INSTANCE_UNIFORM type);
bool VerifyMATERIAL_INSTANCE_UNIFORMVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum GameComponent_Type {
  GameComponent_Type_NONE = 0,
  GameComponent_Type_StaticModel_Component = 1,
  GameComponent_Type_Camera_Component = 2,
  GameComponent_Type_MIN = GameComponent_Type_NONE,
  GameComponent_Type_MAX = GameComponent_Type_Camera_Component
};

inline const GameComponent_Type (&EnumValuesGameComponent_Type())[3] {
  static const GameComponent_Type values[] = {
    GameComponent_Type_NONE,
    GameComponent_Type_StaticModel_Component,
    GameComponent_Type_Camera_Component
  };
  return values;
}

inline const char * const *EnumNamesGameComponent_Type() {
  static const char * const names[4] = {
    "NONE",
    "StaticModel_Component",
    "Camera_Component",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameComponent_Type(GameComponent_Type e) {
  if (e < GameComponent_Type_NONE || e > GameComponent_Type_Camera_Component) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameComponent_Type()[index];
}

template<typename T> struct GameComponent_TypeTraits {
  static const GameComponent_Type enum_value = GameComponent_Type_NONE;
};

template<> struct GameComponent_TypeTraits<GameContent::StaticModel_ComponentTable> {
  static const GameComponent_Type enum_value = GameComponent_Type_StaticModel_Component;
};

template<> struct GameComponent_TypeTraits<GameContent::Camera_ComponentTable> {
  static const GameComponent_Type enum_value = GameComponent_Type_Camera_Component;
};

bool VerifyGameComponent_Type(flatbuffers::Verifier &verifier, const void *obj, GameComponent_Type type);
bool VerifyGameComponent_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum File_Type {
  File_Type_ERROR = 0,
  File_Type_Material_Type = 1,
  File_Type_Material_Instance = 2,
  File_Type_Texture = 3,
  File_Type_Static_Model = 4,
  File_Type_Scene = 5,
  File_Type_MIN = File_Type_ERROR,
  File_Type_MAX = File_Type_Scene
};

inline const File_Type (&EnumValuesFile_Type())[6] {
  static const File_Type values[] = {
    File_Type_ERROR,
    File_Type_Material_Type,
    File_Type_Material_Instance,
    File_Type_Texture,
    File_Type_Static_Model,
    File_Type_Scene
  };
  return values;
}

inline const char * const *EnumNamesFile_Type() {
  static const char * const names[7] = {
    "ERROR",
    "Material_Type",
    "Material_Instance",
    "Texture",
    "Static_Model",
    "Scene",
    nullptr
  };
  return names;
}

inline const char *EnumNameFile_Type(File_Type e) {
  if (e < File_Type_ERROR || e > File_Type_Scene) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFile_Type()[index];
}

enum Resource_Type {
  Resource_Type_NONE = 0,
  Resource_Type_Material_Type = 1,
  Resource_Type_Material_Instance = 2,
  Resource_Type_Texture = 3,
  Resource_Type_Static_Model = 4,
  Resource_Type_Scene = 5,
  Resource_Type_File_List = 6,
  Resource_Type_MIN = Resource_Type_NONE,
  Resource_Type_MAX = Resource_Type_File_List
};

inline const Resource_Type (&EnumValuesResource_Type())[7] {
  static const Resource_Type values[] = {
    Resource_Type_NONE,
    Resource_Type_Material_Type,
    Resource_Type_Material_Instance,
    Resource_Type_Texture,
    Resource_Type_Static_Model,
    Resource_Type_Scene,
    Resource_Type_File_List
  };
  return values;
}

inline const char * const *EnumNamesResource_Type() {
  static const char * const names[8] = {
    "NONE",
    "Material_Type",
    "Material_Instance",
    "Texture",
    "Static_Model",
    "Scene",
    "File_List",
    nullptr
  };
  return names;
}

inline const char *EnumNameResource_Type(Resource_Type e) {
  if (e < Resource_Type_NONE || e > Resource_Type_File_List) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResource_Type()[index];
}

template<typename T> struct Resource_TypeTraits {
  static const Resource_Type enum_value = Resource_Type_NONE;
};

template<> struct Resource_TypeTraits<GameContent::MATERIAL_TYPE> {
  static const Resource_Type enum_value = Resource_Type_Material_Type;
};

template<> struct Resource_TypeTraits<GameContent::MATERIAL_INSTANCE> {
  static const Resource_Type enum_value = Resource_Type_Material_Instance;
};

template<> struct Resource_TypeTraits<GameContent::TEXTURE> {
  static const Resource_Type enum_value = Resource_Type_Texture;
};

template<> struct Resource_TypeTraits<GameContent::STATIC_MODEL> {
  static const Resource_Type enum_value = Resource_Type_Static_Model;
};

template<> struct Resource_TypeTraits<GameContent::SCENE> {
  static const Resource_Type enum_value = Resource_Type_Scene;
};

template<> struct Resource_TypeTraits<GameContent::FileList> {
  static const Resource_Type enum_value = Resource_Type_File_List;
};

bool VerifyResource_Type(flatbuffers::Verifier &verifier, const void *obj, Resource_Type type);
bool VerifyResource_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4() {
    memset(static_cast<void *>(this), 0, sizeof(Vec4));
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat4x4 FLATBUFFERS_FINAL_CLASS {
 private:
  GameContent::Vec4 ROW_1_;
  GameContent::Vec4 ROW_2_;
  GameContent::Vec4 ROW_3_;
  GameContent::Vec4 ROW_4_;

 public:
  Mat4x4() {
    memset(static_cast<void *>(this), 0, sizeof(Mat4x4));
  }
  Mat4x4(const GameContent::Vec4 &_ROW_1, const GameContent::Vec4 &_ROW_2, const GameContent::Vec4 &_ROW_3, const GameContent::Vec4 &_ROW_4)
      : ROW_1_(_ROW_1),
        ROW_2_(_ROW_2),
        ROW_3_(_ROW_3),
        ROW_4_(_ROW_4) {
  }
  const GameContent::Vec4 &ROW_1() const {
    return ROW_1_;
  }
  const GameContent::Vec4 &ROW_2() const {
    return ROW_2_;
  }
  const GameContent::Vec4 &ROW_3() const {
    return ROW_3_;
  }
  const GameContent::Vec4 &ROW_4() const {
    return ROW_4_;
  }
};
FLATBUFFERS_STRUCT_END(Mat4x4, 64);

struct TEXTURE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_DATA = 8,
    VT_DIMENSION = 10,
    VT_CHANNELS = 12,
    VT_VALUE_TYPE = 14,
    VT_MIPMAP_FILTERING = 16,
    VT_WRAPPING = 18
  };
  uint32_t WIDTH() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t HEIGHT() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  const flatbuffers::Vector<uint8_t> *DATA() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  GameContent::TEXTURE_DIMENSION DIMENSION() const {
    return static_cast<GameContent::TEXTURE_DIMENSION>(GetField<uint8_t>(VT_DIMENSION, 0));
  }
  GameContent::TEXTURE_CHANNELs CHANNELs() const {
    return static_cast<GameContent::TEXTURE_CHANNELs>(GetField<uint8_t>(VT_CHANNELS, 0));
  }
  GameContent::TEXTURE_VALUETYPE VALUE_TYPE() const {
    return static_cast<GameContent::TEXTURE_VALUETYPE>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  GameContent::TEXTURE_MIPMAP_FILTERING MIPMAP_FILTERING() const {
    return static_cast<GameContent::TEXTURE_MIPMAP_FILTERING>(GetField<uint8_t>(VT_MIPMAP_FILTERING, 0));
  }
  GameContent::TEXTURE_WRAPPING WRAPPING() const {
    return static_cast<GameContent::TEXTURE_WRAPPING>(GetField<uint8_t>(VT_WRAPPING, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(DATA()) &&
           VerifyField<uint8_t>(verifier, VT_DIMENSION) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELS) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_MIPMAP_FILTERING) &&
           VerifyField<uint8_t>(verifier, VT_WRAPPING) &&
           verifier.EndTable();
  }
};

struct TEXTUREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_WIDTH(uint32_t WIDTH) {
    fbb_.AddElement<uint32_t>(TEXTURE::VT_WIDTH, WIDTH, 0);
  }
  void add_HEIGHT(uint32_t HEIGHT) {
    fbb_.AddElement<uint32_t>(TEXTURE::VT_HEIGHT, HEIGHT, 0);
  }
  void add_DATA(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> DATA) {
    fbb_.AddOffset(TEXTURE::VT_DATA, DATA);
  }
  void add_DIMENSION(GameContent::TEXTURE_DIMENSION DIMENSION) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_DIMENSION, static_cast<uint8_t>(DIMENSION), 0);
  }
  void add_CHANNELs(GameContent::TEXTURE_CHANNELs CHANNELs) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_CHANNELS, static_cast<uint8_t>(CHANNELs), 0);
  }
  void add_VALUE_TYPE(GameContent::TEXTURE_VALUETYPE VALUE_TYPE) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_VALUE_TYPE, static_cast<uint8_t>(VALUE_TYPE), 0);
  }
  void add_MIPMAP_FILTERING(GameContent::TEXTURE_MIPMAP_FILTERING MIPMAP_FILTERING) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_MIPMAP_FILTERING, static_cast<uint8_t>(MIPMAP_FILTERING), 0);
  }
  void add_WRAPPING(GameContent::TEXTURE_WRAPPING WRAPPING) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_WRAPPING, static_cast<uint8_t>(WRAPPING), 0);
  }
  explicit TEXTUREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TEXTUREBuilder &operator=(const TEXTUREBuilder &);
  flatbuffers::Offset<TEXTURE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TEXTURE>(end);
    return o;
  }
};

inline flatbuffers::Offset<TEXTURE> CreateTEXTURE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t WIDTH = 0,
    uint32_t HEIGHT = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> DATA = 0,
    GameContent::TEXTURE_DIMENSION DIMENSION = GameContent::TEXTURE_DIMENSION_TEXTURE_2D,
    GameContent::TEXTURE_CHANNELs CHANNELs = GameContent::TEXTURE_CHANNELs_TEXTURE_RGB,
    GameContent::TEXTURE_VALUETYPE VALUE_TYPE = GameContent::TEXTURE_VALUETYPE_UBYTE8,
    GameContent::TEXTURE_MIPMAP_FILTERING MIPMAP_FILTERING = GameContent::TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP,
    GameContent::TEXTURE_WRAPPING WRAPPING = GameContent::TEXTURE_WRAPPING_REPEAT) {
  TEXTUREBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_HEIGHT(HEIGHT);
  builder_.add_WIDTH(WIDTH);
  builder_.add_WRAPPING(WRAPPING);
  builder_.add_MIPMAP_FILTERING(MIPMAP_FILTERING);
  builder_.add_VALUE_TYPE(VALUE_TYPE);
  builder_.add_CHANNELs(CHANNELs);
  builder_.add_DIMENSION(DIMENSION);
  return builder_.Finish();
}

inline flatbuffers::Offset<TEXTURE> CreateTEXTUREDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t WIDTH = 0,
    uint32_t HEIGHT = 0,
    const std::vector<uint8_t> *DATA = nullptr,
    GameContent::TEXTURE_DIMENSION DIMENSION = GameContent::TEXTURE_DIMENSION_TEXTURE_2D,
    GameContent::TEXTURE_CHANNELs CHANNELs = GameContent::TEXTURE_CHANNELs_TEXTURE_RGB,
    GameContent::TEXTURE_VALUETYPE VALUE_TYPE = GameContent::TEXTURE_VALUETYPE_UBYTE8,
    GameContent::TEXTURE_MIPMAP_FILTERING MIPMAP_FILTERING = GameContent::TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP,
    GameContent::TEXTURE_WRAPPING WRAPPING = GameContent::TEXTURE_WRAPPING_REPEAT) {
  auto DATA__ = DATA ? _fbb.CreateVector<uint8_t>(*DATA) : 0;
  return GameContent::CreateTEXTURE(
      _fbb,
      WIDTH,
      HEIGHT,
      DATA__,
      DIMENSION,
      CHANNELs,
      VALUE_TYPE,
      MIPMAP_FILTERING,
      WRAPPING);
}

struct UNIFORM_UINT32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t DATA() const {
    return GetField<uint32_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<uint32_t>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_UINT32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_UINT32::VT_NAME, NAME);
  }
  void add_DATA(uint32_t DATA) {
    fbb_.AddElement<uint32_t>(UNIFORM_UINT32::VT_DATA, DATA, 0);
  }
  explicit UNIFORM_UINT32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_UINT32Builder &operator=(const UNIFORM_UINT32Builder &);
  flatbuffers::Offset<UNIFORM_UINT32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_UINT32>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_UINT32> CreateUNIFORM_UINT32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    uint32_t DATA = 0) {
  UNIFORM_UINT32Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_UINT32> CreateUNIFORM_UINT32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    uint32_t DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateUNIFORM_UINT32(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_INT32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t DATA() const {
    return GetField<int32_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<int32_t>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_INT32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_INT32::VT_NAME, NAME);
  }
  void add_DATA(int32_t DATA) {
    fbb_.AddElement<int32_t>(UNIFORM_INT32::VT_DATA, DATA, 0);
  }
  explicit UNIFORM_INT32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_INT32Builder &operator=(const UNIFORM_INT32Builder &);
  flatbuffers::Offset<UNIFORM_INT32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_INT32>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_INT32> CreateUNIFORM_INT32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    int32_t DATA = 0) {
  UNIFORM_INT32Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_INT32> CreateUNIFORM_INT32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    int32_t DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateUNIFORM_INT32(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_FLOAT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float DATA() const {
    return GetField<float>(VT_DATA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<float>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_FLOATBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_FLOAT::VT_NAME, NAME);
  }
  void add_DATA(float DATA) {
    fbb_.AddElement<float>(UNIFORM_FLOAT::VT_DATA, DATA, 0.0f);
  }
  explicit UNIFORM_FLOATBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_FLOATBuilder &operator=(const UNIFORM_FLOATBuilder &);
  flatbuffers::Offset<UNIFORM_FLOAT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_FLOAT>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_FLOAT> CreateUNIFORM_FLOAT(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    float DATA = 0.0f) {
  UNIFORM_FLOATBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_FLOAT> CreateUNIFORM_FLOATDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    float DATA = 0.0f) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateUNIFORM_FLOAT(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_VEC2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GameContent::Vec2 *DATA() const {
    return GetStruct<const GameContent::Vec2 *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<GameContent::Vec2>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_VEC2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_VEC2::VT_NAME, NAME);
  }
  void add_DATA(const GameContent::Vec2 *DATA) {
    fbb_.AddStruct(UNIFORM_VEC2::VT_DATA, DATA);
  }
  explicit UNIFORM_VEC2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_VEC2Builder &operator=(const UNIFORM_VEC2Builder &);
  flatbuffers::Offset<UNIFORM_VEC2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_VEC2>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_VEC2> CreateUNIFORM_VEC2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const GameContent::Vec2 *DATA = 0) {
  UNIFORM_VEC2Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_VEC2> CreateUNIFORM_VEC2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const GameContent::Vec2 *DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateUNIFORM_VEC2(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_VEC3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GameContent::Vec3 *DATA() const {
    return GetStruct<const GameContent::Vec3 *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<GameContent::Vec3>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_VEC3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_VEC3::VT_NAME, NAME);
  }
  void add_DATA(const GameContent::Vec3 *DATA) {
    fbb_.AddStruct(UNIFORM_VEC3::VT_DATA, DATA);
  }
  explicit UNIFORM_VEC3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_VEC3Builder &operator=(const UNIFORM_VEC3Builder &);
  flatbuffers::Offset<UNIFORM_VEC3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_VEC3>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_VEC3> CreateUNIFORM_VEC3(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const GameContent::Vec3 *DATA = 0) {
  UNIFORM_VEC3Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_VEC3> CreateUNIFORM_VEC3Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const GameContent::Vec3 *DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateUNIFORM_VEC3(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_VEC4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GameContent::Vec4 *DATA() const {
    return GetStruct<const GameContent::Vec4 *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<GameContent::Vec4>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_VEC4Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_VEC4::VT_NAME, NAME);
  }
  void add_DATA(const GameContent::Vec4 *DATA) {
    fbb_.AddStruct(UNIFORM_VEC4::VT_DATA, DATA);
  }
  explicit UNIFORM_VEC4Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_VEC4Builder &operator=(const UNIFORM_VEC4Builder &);
  flatbuffers::Offset<UNIFORM_VEC4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_VEC4>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_VEC4> CreateUNIFORM_VEC4(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const GameContent::Vec4 *DATA = 0) {
  UNIFORM_VEC4Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_VEC4> CreateUNIFORM_VEC4Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const GameContent::Vec4 *DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateUNIFORM_VEC4(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_MAT4x4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GameContent::Mat4x4 *DATA() const {
    return GetStruct<const GameContent::Mat4x4 *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<GameContent::Mat4x4>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_MAT4x4Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_MAT4x4::VT_NAME, NAME);
  }
  void add_DATA(const GameContent::Mat4x4 *DATA) {
    fbb_.AddStruct(UNIFORM_MAT4x4::VT_DATA, DATA);
  }
  explicit UNIFORM_MAT4x4Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_MAT4x4Builder &operator=(const UNIFORM_MAT4x4Builder &);
  flatbuffers::Offset<UNIFORM_MAT4x4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_MAT4x4>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_MAT4x4> CreateUNIFORM_MAT4x4(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const GameContent::Mat4x4 *DATA = 0) {
  UNIFORM_MAT4x4Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_MAT4x4> CreateUNIFORM_MAT4x4Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const GameContent::Mat4x4 *DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateUNIFORM_MAT4x4(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_TEXTURE2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t DATA() const {
    return GetField<uint32_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<uint32_t>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_TEXTURE2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_TEXTURE2D::VT_NAME, NAME);
  }
  void add_DATA(uint32_t DATA) {
    fbb_.AddElement<uint32_t>(UNIFORM_TEXTURE2D::VT_DATA, DATA, 0);
  }
  explicit UNIFORM_TEXTURE2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_TEXTURE2DBuilder &operator=(const UNIFORM_TEXTURE2DBuilder &);
  flatbuffers::Offset<UNIFORM_TEXTURE2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_TEXTURE2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_TEXTURE2D> CreateUNIFORM_TEXTURE2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    uint32_t DATA = 0) {
  UNIFORM_TEXTURE2DBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_TEXTURE2D> CreateUNIFORM_TEXTURE2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    uint32_t DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateUNIFORM_TEXTURE2D(
      _fbb,
      NAME__,
      DATA);
}

struct MATERIAL_INSTANCE_UNIFORM_TABLE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIFORM_TYPE = 4,
    VT_UNIFORM = 6
  };
  GameContent::MATERIAL_INSTANCE_UNIFORM UNIFORM_type() const {
    return static_cast<GameContent::MATERIAL_INSTANCE_UNIFORM>(GetField<uint8_t>(VT_UNIFORM_TYPE, 0));
  }
  const void *UNIFORM() const {
    return GetPointer<const void *>(VT_UNIFORM);
  }
  template<typename T> const T *UNIFORM_as() const;
  const GameContent::UNIFORM_UINT32 *UNIFORM_as_UINT32() const {
    return UNIFORM_type() == GameContent::MATERIAL_INSTANCE_UNIFORM_UINT32 ? static_cast<const GameContent::UNIFORM_UINT32 *>(UNIFORM()) : nullptr;
  }
  const GameContent::UNIFORM_INT32 *UNIFORM_as_INT32() const {
    return UNIFORM_type() == GameContent::MATERIAL_INSTANCE_UNIFORM_INT32 ? static_cast<const GameContent::UNIFORM_INT32 *>(UNIFORM()) : nullptr;
  }
  const GameContent::UNIFORM_FLOAT *UNIFORM_as_FLOAT() const {
    return UNIFORM_type() == GameContent::MATERIAL_INSTANCE_UNIFORM_FLOAT ? static_cast<const GameContent::UNIFORM_FLOAT *>(UNIFORM()) : nullptr;
  }
  const GameContent::UNIFORM_VEC2 *UNIFORM_as_VEC2() const {
    return UNIFORM_type() == GameContent::MATERIAL_INSTANCE_UNIFORM_VEC2 ? static_cast<const GameContent::UNIFORM_VEC2 *>(UNIFORM()) : nullptr;
  }
  const GameContent::UNIFORM_VEC3 *UNIFORM_as_VEC3() const {
    return UNIFORM_type() == GameContent::MATERIAL_INSTANCE_UNIFORM_VEC3 ? static_cast<const GameContent::UNIFORM_VEC3 *>(UNIFORM()) : nullptr;
  }
  const GameContent::UNIFORM_VEC4 *UNIFORM_as_VEC4() const {
    return UNIFORM_type() == GameContent::MATERIAL_INSTANCE_UNIFORM_VEC4 ? static_cast<const GameContent::UNIFORM_VEC4 *>(UNIFORM()) : nullptr;
  }
  const GameContent::UNIFORM_MAT4x4 *UNIFORM_as_Mat4x4() const {
    return UNIFORM_type() == GameContent::MATERIAL_INSTANCE_UNIFORM_Mat4x4 ? static_cast<const GameContent::UNIFORM_MAT4x4 *>(UNIFORM()) : nullptr;
  }
  const GameContent::UNIFORM_TEXTURE2D *UNIFORM_as_TEXTURE2D() const {
    return UNIFORM_type() == GameContent::MATERIAL_INSTANCE_UNIFORM_TEXTURE2D ? static_cast<const GameContent::UNIFORM_TEXTURE2D *>(UNIFORM()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_UNIFORM_TYPE) &&
           VerifyOffset(verifier, VT_UNIFORM) &&
           VerifyMATERIAL_INSTANCE_UNIFORM(verifier, UNIFORM(), UNIFORM_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GameContent::UNIFORM_UINT32 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GameContent::UNIFORM_UINT32>() const {
  return UNIFORM_as_UINT32();
}

template<> inline const GameContent::UNIFORM_INT32 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GameContent::UNIFORM_INT32>() const {
  return UNIFORM_as_INT32();
}

template<> inline const GameContent::UNIFORM_FLOAT *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GameContent::UNIFORM_FLOAT>() const {
  return UNIFORM_as_FLOAT();
}

template<> inline const GameContent::UNIFORM_VEC2 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GameContent::UNIFORM_VEC2>() const {
  return UNIFORM_as_VEC2();
}

template<> inline const GameContent::UNIFORM_VEC3 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GameContent::UNIFORM_VEC3>() const {
  return UNIFORM_as_VEC3();
}

template<> inline const GameContent::UNIFORM_VEC4 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GameContent::UNIFORM_VEC4>() const {
  return UNIFORM_as_VEC4();
}

template<> inline const GameContent::UNIFORM_MAT4x4 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GameContent::UNIFORM_MAT4x4>() const {
  return UNIFORM_as_Mat4x4();
}

template<> inline const GameContent::UNIFORM_TEXTURE2D *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GameContent::UNIFORM_TEXTURE2D>() const {
  return UNIFORM_as_TEXTURE2D();
}

struct MATERIAL_INSTANCE_UNIFORM_TABLEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_UNIFORM_type(GameContent::MATERIAL_INSTANCE_UNIFORM UNIFORM_type) {
    fbb_.AddElement<uint8_t>(MATERIAL_INSTANCE_UNIFORM_TABLE::VT_UNIFORM_TYPE, static_cast<uint8_t>(UNIFORM_type), 0);
  }
  void add_UNIFORM(flatbuffers::Offset<void> UNIFORM) {
    fbb_.AddOffset(MATERIAL_INSTANCE_UNIFORM_TABLE::VT_UNIFORM, UNIFORM);
  }
  explicit MATERIAL_INSTANCE_UNIFORM_TABLEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MATERIAL_INSTANCE_UNIFORM_TABLEBuilder &operator=(const MATERIAL_INSTANCE_UNIFORM_TABLEBuilder &);
  flatbuffers::Offset<MATERIAL_INSTANCE_UNIFORM_TABLE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MATERIAL_INSTANCE_UNIFORM_TABLE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MATERIAL_INSTANCE_UNIFORM_TABLE> CreateMATERIAL_INSTANCE_UNIFORM_TABLE(
    flatbuffers::FlatBufferBuilder &_fbb,
    GameContent::MATERIAL_INSTANCE_UNIFORM UNIFORM_type = GameContent::MATERIAL_INSTANCE_UNIFORM_NONE,
    flatbuffers::Offset<void> UNIFORM = 0) {
  MATERIAL_INSTANCE_UNIFORM_TABLEBuilder builder_(_fbb);
  builder_.add_UNIFORM(UNIFORM);
  builder_.add_UNIFORM_type(UNIFORM_type);
  return builder_.Finish();
}

struct MATERIAL_TYPE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GFX_API = 4,
    VT_VERTEX_SHADER = 6,
    VT_FRAGMENT_SHADER = 8,
    VT_MATERIAL_INPUTS = 10
  };
  GameContent::GFX_APIs GFX_API() const {
    return static_cast<GameContent::GFX_APIs>(GetField<uint8_t>(VT_GFX_API, 0));
  }
  const flatbuffers::String *VERTEX_SHADER() const {
    return GetPointer<const flatbuffers::String *>(VT_VERTEX_SHADER);
  }
  const flatbuffers::String *FRAGMENT_SHADER() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAGMENT_SHADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>> *MATERIAL_INPUTs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>> *>(VT_MATERIAL_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GFX_API) &&
           VerifyOffset(verifier, VT_VERTEX_SHADER) &&
           verifier.VerifyString(VERTEX_SHADER()) &&
           VerifyOffset(verifier, VT_FRAGMENT_SHADER) &&
           verifier.VerifyString(FRAGMENT_SHADER()) &&
           VerifyOffset(verifier, VT_MATERIAL_INPUTS) &&
           verifier.VerifyVector(MATERIAL_INPUTs()) &&
           verifier.VerifyVectorOfTables(MATERIAL_INPUTs()) &&
           verifier.EndTable();
  }
};

struct MATERIAL_TYPEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GFX_API(GameContent::GFX_APIs GFX_API) {
    fbb_.AddElement<uint8_t>(MATERIAL_TYPE::VT_GFX_API, static_cast<uint8_t>(GFX_API), 0);
  }
  void add_VERTEX_SHADER(flatbuffers::Offset<flatbuffers::String> VERTEX_SHADER) {
    fbb_.AddOffset(MATERIAL_TYPE::VT_VERTEX_SHADER, VERTEX_SHADER);
  }
  void add_FRAGMENT_SHADER(flatbuffers::Offset<flatbuffers::String> FRAGMENT_SHADER) {
    fbb_.AddOffset(MATERIAL_TYPE::VT_FRAGMENT_SHADER, FRAGMENT_SHADER);
  }
  void add_MATERIAL_INPUTs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>>> MATERIAL_INPUTs) {
    fbb_.AddOffset(MATERIAL_TYPE::VT_MATERIAL_INPUTS, MATERIAL_INPUTs);
  }
  explicit MATERIAL_TYPEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MATERIAL_TYPEBuilder &operator=(const MATERIAL_TYPEBuilder &);
  flatbuffers::Offset<MATERIAL_TYPE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MATERIAL_TYPE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MATERIAL_TYPE> CreateMATERIAL_TYPE(
    flatbuffers::FlatBufferBuilder &_fbb,
    GameContent::GFX_APIs GFX_API = GameContent::GFX_APIs_OPENGL3,
    flatbuffers::Offset<flatbuffers::String> VERTEX_SHADER = 0,
    flatbuffers::Offset<flatbuffers::String> FRAGMENT_SHADER = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>>> MATERIAL_INPUTs = 0) {
  MATERIAL_TYPEBuilder builder_(_fbb);
  builder_.add_MATERIAL_INPUTs(MATERIAL_INPUTs);
  builder_.add_FRAGMENT_SHADER(FRAGMENT_SHADER);
  builder_.add_VERTEX_SHADER(VERTEX_SHADER);
  builder_.add_GFX_API(GFX_API);
  return builder_.Finish();
}

inline flatbuffers::Offset<MATERIAL_TYPE> CreateMATERIAL_TYPEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GameContent::GFX_APIs GFX_API = GameContent::GFX_APIs_OPENGL3,
    const char *VERTEX_SHADER = nullptr,
    const char *FRAGMENT_SHADER = nullptr,
    const std::vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>> *MATERIAL_INPUTs = nullptr) {
  auto VERTEX_SHADER__ = VERTEX_SHADER ? _fbb.CreateString(VERTEX_SHADER) : 0;
  auto FRAGMENT_SHADER__ = FRAGMENT_SHADER ? _fbb.CreateString(FRAGMENT_SHADER) : 0;
  auto MATERIAL_INPUTs__ = MATERIAL_INPUTs ? _fbb.CreateVector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>>(*MATERIAL_INPUTs) : 0;
  return GameContent::CreateMATERIAL_TYPE(
      _fbb,
      GFX_API,
      VERTEX_SHADER__,
      FRAGMENT_SHADER__,
      MATERIAL_INPUTs__);
}

struct MATERIAL_INSTANCE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL_TYPE_ID = 4,
    VT_UNIFORMS = 6
  };
  uint16_t MATERIAL_TYPE_ID() const {
    return GetField<uint16_t>(VT_MATERIAL_TYPE_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>> *UNIFORMs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>> *>(VT_UNIFORMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MATERIAL_TYPE_ID) &&
           VerifyOffset(verifier, VT_UNIFORMS) &&
           verifier.VerifyVector(UNIFORMs()) &&
           verifier.VerifyVectorOfTables(UNIFORMs()) &&
           verifier.EndTable();
  }
};

struct MATERIAL_INSTANCEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MATERIAL_TYPE_ID(uint16_t MATERIAL_TYPE_ID) {
    fbb_.AddElement<uint16_t>(MATERIAL_INSTANCE::VT_MATERIAL_TYPE_ID, MATERIAL_TYPE_ID, 0);
  }
  void add_UNIFORMs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>>> UNIFORMs) {
    fbb_.AddOffset(MATERIAL_INSTANCE::VT_UNIFORMS, UNIFORMs);
  }
  explicit MATERIAL_INSTANCEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MATERIAL_INSTANCEBuilder &operator=(const MATERIAL_INSTANCEBuilder &);
  flatbuffers::Offset<MATERIAL_INSTANCE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MATERIAL_INSTANCE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MATERIAL_INSTANCE> CreateMATERIAL_INSTANCE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t MATERIAL_TYPE_ID = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>>> UNIFORMs = 0) {
  MATERIAL_INSTANCEBuilder builder_(_fbb);
  builder_.add_UNIFORMs(UNIFORMs);
  builder_.add_MATERIAL_TYPE_ID(MATERIAL_TYPE_ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<MATERIAL_INSTANCE> CreateMATERIAL_INSTANCEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t MATERIAL_TYPE_ID = 0,
    const std::vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>> *UNIFORMs = nullptr) {
  auto UNIFORMs__ = UNIFORMs ? _fbb.CreateVector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE_UNIFORM_TABLE>>(*UNIFORMs) : 0;
  return GameContent::CreateMATERIAL_INSTANCE(
      _fbb,
      MATERIAL_TYPE_ID,
      UNIFORMs__);
}

struct MESH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITIONS = 4,
    VT_TEXTCOORDS = 6,
    VT_NORMALS = 8,
    VT_TANGENTS = 10,
    VT_BITANGENTS = 12,
    VT_INDICES = 14
  };
  const flatbuffers::Vector<const GameContent::Vec3 *> *Positions() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec3 *> *>(VT_POSITIONS);
  }
  const flatbuffers::Vector<const GameContent::Vec2 *> *TextCoords() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec2 *> *>(VT_TEXTCOORDS);
  }
  const flatbuffers::Vector<const GameContent::Vec3 *> *Normals() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec3 *> *>(VT_NORMALS);
  }
  const flatbuffers::Vector<const GameContent::Vec3 *> *Tangents() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec3 *> *>(VT_TANGENTS);
  }
  const flatbuffers::Vector<const GameContent::Vec3 *> *Bitangents() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec3 *> *>(VT_BITANGENTS);
  }
  const flatbuffers::Vector<uint32_t> *Indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(Positions()) &&
           VerifyOffset(verifier, VT_TEXTCOORDS) &&
           verifier.VerifyVector(TextCoords()) &&
           VerifyOffset(verifier, VT_NORMALS) &&
           verifier.VerifyVector(Normals()) &&
           VerifyOffset(verifier, VT_TANGENTS) &&
           verifier.VerifyVector(Tangents()) &&
           VerifyOffset(verifier, VT_BITANGENTS) &&
           verifier.VerifyVector(Bitangents()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(Indices()) &&
           verifier.EndTable();
  }
};

struct MESHBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Positions(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Positions) {
    fbb_.AddOffset(MESH::VT_POSITIONS, Positions);
  }
  void add_TextCoords(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec2 *>> TextCoords) {
    fbb_.AddOffset(MESH::VT_TEXTCOORDS, TextCoords);
  }
  void add_Normals(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Normals) {
    fbb_.AddOffset(MESH::VT_NORMALS, Normals);
  }
  void add_Tangents(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Tangents) {
    fbb_.AddOffset(MESH::VT_TANGENTS, Tangents);
  }
  void add_Bitangents(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Bitangents) {
    fbb_.AddOffset(MESH::VT_BITANGENTS, Bitangents);
  }
  void add_Indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> Indices) {
    fbb_.AddOffset(MESH::VT_INDICES, Indices);
  }
  explicit MESHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MESHBuilder &operator=(const MESHBuilder &);
  flatbuffers::Offset<MESH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MESH>(end);
    return o;
  }
};

inline flatbuffers::Offset<MESH> CreateMESH(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec2 *>> TextCoords = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Normals = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Tangents = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Bitangents = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> Indices = 0) {
  MESHBuilder builder_(_fbb);
  builder_.add_Indices(Indices);
  builder_.add_Bitangents(Bitangents);
  builder_.add_Tangents(Tangents);
  builder_.add_Normals(Normals);
  builder_.add_TextCoords(TextCoords);
  builder_.add_Positions(Positions);
  return builder_.Finish();
}

inline flatbuffers::Offset<MESH> CreateMESHDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<GameContent::Vec3> *Positions = nullptr,
    const std::vector<GameContent::Vec2> *TextCoords = nullptr,
    const std::vector<GameContent::Vec3> *Normals = nullptr,
    const std::vector<GameContent::Vec3> *Tangents = nullptr,
    const std::vector<GameContent::Vec3> *Bitangents = nullptr,
    const std::vector<uint32_t> *Indices = nullptr) {
  auto Positions__ = Positions ? _fbb.CreateVectorOfStructs<GameContent::Vec3>(*Positions) : 0;
  auto TextCoords__ = TextCoords ? _fbb.CreateVectorOfStructs<GameContent::Vec2>(*TextCoords) : 0;
  auto Normals__ = Normals ? _fbb.CreateVectorOfStructs<GameContent::Vec3>(*Normals) : 0;
  auto Tangents__ = Tangents ? _fbb.CreateVectorOfStructs<GameContent::Vec3>(*Tangents) : 0;
  auto Bitangents__ = Bitangents ? _fbb.CreateVectorOfStructs<GameContent::Vec3>(*Bitangents) : 0;
  auto Indices__ = Indices ? _fbb.CreateVector<uint32_t>(*Indices) : 0;
  return GameContent::CreateMESH(
      _fbb,
      Positions__,
      TextCoords__,
      Normals__,
      Tangents__,
      Bitangents__,
      Indices__);
}

struct STATIC_MODEL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESHES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<GameContent::MESH>> *MESHes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameContent::MESH>> *>(VT_MESHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(MESHes()) &&
           verifier.VerifyVectorOfTables(MESHes()) &&
           verifier.EndTable();
  }
};

struct STATIC_MODELBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MESHes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MESH>>> MESHes) {
    fbb_.AddOffset(STATIC_MODEL::VT_MESHES, MESHes);
  }
  explicit STATIC_MODELBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  STATIC_MODELBuilder &operator=(const STATIC_MODELBuilder &);
  flatbuffers::Offset<STATIC_MODEL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<STATIC_MODEL>(end);
    return o;
  }
};

inline flatbuffers::Offset<STATIC_MODEL> CreateSTATIC_MODEL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MESH>>> MESHes = 0) {
  STATIC_MODELBuilder builder_(_fbb);
  builder_.add_MESHes(MESHes);
  return builder_.Finish();
}

inline flatbuffers::Offset<STATIC_MODEL> CreateSTATIC_MODELDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GameContent::MESH>> *MESHes = nullptr) {
  auto MESHes__ = MESHes ? _fbb.CreateVector<flatbuffers::Offset<GameContent::MESH>>(*MESHes) : 0;
  return GameContent::CreateSTATIC_MODEL(
      _fbb,
      MESHes__);
}

struct StaticModel_ComponentTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MODEL_ID = 6,
    VT_MATERIALINSTANCES_IDS = 8,
    VT_LOCATION = 10,
    VT_ROTATION = 12,
    VT_SCALE = 14
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t Model_ID() const {
    return GetField<uint32_t>(VT_MODEL_ID, 0);
  }
  const flatbuffers::Vector<uint32_t> *MaterialInstances_IDs() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MATERIALINSTANCES_IDS);
  }
  const GameContent::Vec3 *LOCATION() const {
    return GetStruct<const GameContent::Vec3 *>(VT_LOCATION);
  }
  const GameContent::Vec3 *ROTATION() const {
    return GetStruct<const GameContent::Vec3 *>(VT_ROTATION);
  }
  const GameContent::Vec3 *SCALE() const {
    return GetStruct<const GameContent::Vec3 *>(VT_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<uint32_t>(verifier, VT_MODEL_ID) &&
           VerifyOffset(verifier, VT_MATERIALINSTANCES_IDS) &&
           verifier.VerifyVector(MaterialInstances_IDs()) &&
           VerifyField<GameContent::Vec3>(verifier, VT_LOCATION) &&
           VerifyField<GameContent::Vec3>(verifier, VT_ROTATION) &&
           VerifyField<GameContent::Vec3>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
};

struct StaticModel_ComponentTableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(StaticModel_ComponentTable::VT_NAME, NAME);
  }
  void add_Model_ID(uint32_t Model_ID) {
    fbb_.AddElement<uint32_t>(StaticModel_ComponentTable::VT_MODEL_ID, Model_ID, 0);
  }
  void add_MaterialInstances_IDs(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> MaterialInstances_IDs) {
    fbb_.AddOffset(StaticModel_ComponentTable::VT_MATERIALINSTANCES_IDS, MaterialInstances_IDs);
  }
  void add_LOCATION(const GameContent::Vec3 *LOCATION) {
    fbb_.AddStruct(StaticModel_ComponentTable::VT_LOCATION, LOCATION);
  }
  void add_ROTATION(const GameContent::Vec3 *ROTATION) {
    fbb_.AddStruct(StaticModel_ComponentTable::VT_ROTATION, ROTATION);
  }
  void add_SCALE(const GameContent::Vec3 *SCALE) {
    fbb_.AddStruct(StaticModel_ComponentTable::VT_SCALE, SCALE);
  }
  explicit StaticModel_ComponentTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StaticModel_ComponentTableBuilder &operator=(const StaticModel_ComponentTableBuilder &);
  flatbuffers::Offset<StaticModel_ComponentTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StaticModel_ComponentTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<StaticModel_ComponentTable> CreateStaticModel_ComponentTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    uint32_t Model_ID = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> MaterialInstances_IDs = 0,
    const GameContent::Vec3 *LOCATION = 0,
    const GameContent::Vec3 *ROTATION = 0,
    const GameContent::Vec3 *SCALE = 0) {
  StaticModel_ComponentTableBuilder builder_(_fbb);
  builder_.add_SCALE(SCALE);
  builder_.add_ROTATION(ROTATION);
  builder_.add_LOCATION(LOCATION);
  builder_.add_MaterialInstances_IDs(MaterialInstances_IDs);
  builder_.add_Model_ID(Model_ID);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<StaticModel_ComponentTable> CreateStaticModel_ComponentTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    uint32_t Model_ID = 0,
    const std::vector<uint32_t> *MaterialInstances_IDs = nullptr,
    const GameContent::Vec3 *LOCATION = 0,
    const GameContent::Vec3 *ROTATION = 0,
    const GameContent::Vec3 *SCALE = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto MaterialInstances_IDs__ = MaterialInstances_IDs ? _fbb.CreateVector<uint32_t>(*MaterialInstances_IDs) : 0;
  return GameContent::CreateStaticModel_ComponentTable(
      _fbb,
      NAME__,
      Model_ID,
      MaterialInstances_IDs__,
      LOCATION,
      ROTATION,
      SCALE);
}

struct Camera_ComponentTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_LOCATION = 6,
    VT_FOV_INANGLE = 8,
    VT_ASPECT_WIDTH = 10,
    VT_ASPECT_HEIGHT = 12,
    VT_NEAR_PLANE = 14,
    VT_FAR_PLANE = 16,
    VT_TARGET = 18
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GameContent::Vec3 *LOCATION() const {
    return GetStruct<const GameContent::Vec3 *>(VT_LOCATION);
  }
  uint16_t FOV_inAngle() const {
    return GetField<uint16_t>(VT_FOV_INANGLE, 0);
  }
  uint16_t Aspect_WIDTH() const {
    return GetField<uint16_t>(VT_ASPECT_WIDTH, 0);
  }
  uint16_t Aspect_HEIGHT() const {
    return GetField<uint16_t>(VT_ASPECT_HEIGHT, 0);
  }
  float Near_Plane() const {
    return GetField<float>(VT_NEAR_PLANE, 0.0f);
  }
  float Far_Plane() const {
    return GetField<float>(VT_FAR_PLANE, 0.0f);
  }
  const GameContent::Vec3 *Target() const {
    return GetStruct<const GameContent::Vec3 *>(VT_TARGET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<GameContent::Vec3>(verifier, VT_LOCATION) &&
           VerifyField<uint16_t>(verifier, VT_FOV_INANGLE) &&
           VerifyField<uint16_t>(verifier, VT_ASPECT_WIDTH) &&
           VerifyField<uint16_t>(verifier, VT_ASPECT_HEIGHT) &&
           VerifyField<float>(verifier, VT_NEAR_PLANE) &&
           VerifyField<float>(verifier, VT_FAR_PLANE) &&
           VerifyField<GameContent::Vec3>(verifier, VT_TARGET) &&
           verifier.EndTable();
  }
};

struct Camera_ComponentTableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(Camera_ComponentTable::VT_NAME, NAME);
  }
  void add_LOCATION(const GameContent::Vec3 *LOCATION) {
    fbb_.AddStruct(Camera_ComponentTable::VT_LOCATION, LOCATION);
  }
  void add_FOV_inAngle(uint16_t FOV_inAngle) {
    fbb_.AddElement<uint16_t>(Camera_ComponentTable::VT_FOV_INANGLE, FOV_inAngle, 0);
  }
  void add_Aspect_WIDTH(uint16_t Aspect_WIDTH) {
    fbb_.AddElement<uint16_t>(Camera_ComponentTable::VT_ASPECT_WIDTH, Aspect_WIDTH, 0);
  }
  void add_Aspect_HEIGHT(uint16_t Aspect_HEIGHT) {
    fbb_.AddElement<uint16_t>(Camera_ComponentTable::VT_ASPECT_HEIGHT, Aspect_HEIGHT, 0);
  }
  void add_Near_Plane(float Near_Plane) {
    fbb_.AddElement<float>(Camera_ComponentTable::VT_NEAR_PLANE, Near_Plane, 0.0f);
  }
  void add_Far_Plane(float Far_Plane) {
    fbb_.AddElement<float>(Camera_ComponentTable::VT_FAR_PLANE, Far_Plane, 0.0f);
  }
  void add_Target(const GameContent::Vec3 *Target) {
    fbb_.AddStruct(Camera_ComponentTable::VT_TARGET, Target);
  }
  explicit Camera_ComponentTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Camera_ComponentTableBuilder &operator=(const Camera_ComponentTableBuilder &);
  flatbuffers::Offset<Camera_ComponentTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Camera_ComponentTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<Camera_ComponentTable> CreateCamera_ComponentTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const GameContent::Vec3 *LOCATION = 0,
    uint16_t FOV_inAngle = 0,
    uint16_t Aspect_WIDTH = 0,
    uint16_t Aspect_HEIGHT = 0,
    float Near_Plane = 0.0f,
    float Far_Plane = 0.0f,
    const GameContent::Vec3 *Target = 0) {
  Camera_ComponentTableBuilder builder_(_fbb);
  builder_.add_Target(Target);
  builder_.add_Far_Plane(Far_Plane);
  builder_.add_Near_Plane(Near_Plane);
  builder_.add_LOCATION(LOCATION);
  builder_.add_NAME(NAME);
  builder_.add_Aspect_HEIGHT(Aspect_HEIGHT);
  builder_.add_Aspect_WIDTH(Aspect_WIDTH);
  builder_.add_FOV_inAngle(FOV_inAngle);
  return builder_.Finish();
}

inline flatbuffers::Offset<Camera_ComponentTable> CreateCamera_ComponentTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const GameContent::Vec3 *LOCATION = 0,
    uint16_t FOV_inAngle = 0,
    uint16_t Aspect_WIDTH = 0,
    uint16_t Aspect_HEIGHT = 0,
    float Near_Plane = 0.0f,
    float Far_Plane = 0.0f,
    const GameContent::Vec3 *Target = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateCamera_ComponentTable(
      _fbb,
      NAME__,
      LOCATION,
      FOV_inAngle,
      Aspect_WIDTH,
      Aspect_HEIGHT,
      Near_Plane,
      Far_Plane,
      Target);
}

struct GameComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPONENT_TYPE = 4,
    VT_COMPONENT = 6
  };
  GameContent::GameComponent_Type COMPONENT_type() const {
    return static_cast<GameContent::GameComponent_Type>(GetField<uint8_t>(VT_COMPONENT_TYPE, 0));
  }
  const void *COMPONENT() const {
    return GetPointer<const void *>(VT_COMPONENT);
  }
  template<typename T> const T *COMPONENT_as() const;
  const GameContent::StaticModel_ComponentTable *COMPONENT_as_StaticModel_Component() const {
    return COMPONENT_type() == GameContent::GameComponent_Type_StaticModel_Component ? static_cast<const GameContent::StaticModel_ComponentTable *>(COMPONENT()) : nullptr;
  }
  const GameContent::Camera_ComponentTable *COMPONENT_as_Camera_Component() const {
    return COMPONENT_type() == GameContent::GameComponent_Type_Camera_Component ? static_cast<const GameContent::Camera_ComponentTable *>(COMPONENT()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMPONENT_TYPE) &&
           VerifyOffset(verifier, VT_COMPONENT) &&
           VerifyGameComponent_Type(verifier, COMPONENT(), COMPONENT_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GameContent::StaticModel_ComponentTable *GameComponent::COMPONENT_as<GameContent::StaticModel_ComponentTable>() const {
  return COMPONENT_as_StaticModel_Component();
}

template<> inline const GameContent::Camera_ComponentTable *GameComponent::COMPONENT_as<GameContent::Camera_ComponentTable>() const {
  return COMPONENT_as_Camera_Component();
}

struct GameComponentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_COMPONENT_type(GameContent::GameComponent_Type COMPONENT_type) {
    fbb_.AddElement<uint8_t>(GameComponent::VT_COMPONENT_TYPE, static_cast<uint8_t>(COMPONENT_type), 0);
  }
  void add_COMPONENT(flatbuffers::Offset<void> COMPONENT) {
    fbb_.AddOffset(GameComponent::VT_COMPONENT, COMPONENT);
  }
  explicit GameComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameComponentBuilder &operator=(const GameComponentBuilder &);
  flatbuffers::Offset<GameComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameComponent> CreateGameComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    GameContent::GameComponent_Type COMPONENT_type = GameContent::GameComponent_Type_NONE,
    flatbuffers::Offset<void> COMPONENT = 0) {
  GameComponentBuilder builder_(_fbb);
  builder_.add_COMPONENT(COMPONENT);
  builder_.add_COMPONENT_type(COMPONENT_type);
  return builder_.Finish();
}

struct SCENE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_COMPONENTS = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GameContent::GameComponent>> *COMPONENTs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameContent::GameComponent>> *>(VT_COMPONENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_COMPONENTS) &&
           verifier.VerifyVector(COMPONENTs()) &&
           verifier.VerifyVectorOfTables(COMPONENTs()) &&
           verifier.EndTable();
  }
};

struct SCENEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(SCENE::VT_NAME, NAME);
  }
  void add_COMPONENTs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::GameComponent>>> COMPONENTs) {
    fbb_.AddOffset(SCENE::VT_COMPONENTS, COMPONENTs);
  }
  explicit SCENEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SCENEBuilder &operator=(const SCENEBuilder &);
  flatbuffers::Offset<SCENE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SCENE>(end);
    return o;
  }
};

inline flatbuffers::Offset<SCENE> CreateSCENE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::GameComponent>>> COMPONENTs = 0) {
  SCENEBuilder builder_(_fbb);
  builder_.add_COMPONENTs(COMPONENTs);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<SCENE> CreateSCENEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const std::vector<flatbuffers::Offset<GameContent::GameComponent>> *COMPONENTs = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto COMPONENTs__ = COMPONENTs ? _fbb.CreateVector<flatbuffers::Offset<GameContent::GameComponent>>(*COMPONENTs) : 0;
  return GameContent::CreateSCENE(
      _fbb,
      NAME__,
      COMPONENTs__);
}

struct File FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_TYPE = 6,
    VT_ID = 8
  };
  const flatbuffers::String *PATH() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  GameContent::File_Type TYPE() const {
    return static_cast<GameContent::File_Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint32_t ID() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(PATH()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct FileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PATH(flatbuffers::Offset<flatbuffers::String> PATH) {
    fbb_.AddOffset(File::VT_PATH, PATH);
  }
  void add_TYPE(GameContent::File_Type TYPE) {
    fbb_.AddElement<uint8_t>(File::VT_TYPE, static_cast<uint8_t>(TYPE), 0);
  }
  void add_ID(uint32_t ID) {
    fbb_.AddElement<uint32_t>(File::VT_ID, ID, 0);
  }
  explicit FileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileBuilder &operator=(const FileBuilder &);
  flatbuffers::Offset<File> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<File>(end);
    return o;
  }
};

inline flatbuffers::Offset<File> CreateFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> PATH = 0,
    GameContent::File_Type TYPE = GameContent::File_Type_ERROR,
    uint32_t ID = 0) {
  FileBuilder builder_(_fbb);
  builder_.add_ID(ID);
  builder_.add_PATH(PATH);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline flatbuffers::Offset<File> CreateFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *PATH = nullptr,
    GameContent::File_Type TYPE = GameContent::File_Type_ERROR,
    uint32_t ID = 0) {
  auto PATH__ = PATH ? _fbb.CreateString(PATH) : 0;
  return GameContent::CreateFile(
      _fbb,
      PATH__,
      TYPE,
      ID);
}

struct FileList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_LIST = 4,
    VT_LAST_ID = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<GameContent::File>> *FILE_LIST() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameContent::File>> *>(VT_FILE_LIST);
  }
  uint32_t LAST_ID() const {
    return GetField<uint32_t>(VT_LAST_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE_LIST) &&
           verifier.VerifyVector(FILE_LIST()) &&
           verifier.VerifyVectorOfTables(FILE_LIST()) &&
           VerifyField<uint32_t>(verifier, VT_LAST_ID) &&
           verifier.EndTable();
  }
};

struct FileListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FILE_LIST(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::File>>> FILE_LIST) {
    fbb_.AddOffset(FileList::VT_FILE_LIST, FILE_LIST);
  }
  void add_LAST_ID(uint32_t LAST_ID) {
    fbb_.AddElement<uint32_t>(FileList::VT_LAST_ID, LAST_ID, 0);
  }
  explicit FileListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileListBuilder &operator=(const FileListBuilder &);
  flatbuffers::Offset<FileList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileList>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileList> CreateFileList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::File>>> FILE_LIST = 0,
    uint32_t LAST_ID = 0) {
  FileListBuilder builder_(_fbb);
  builder_.add_LAST_ID(LAST_ID);
  builder_.add_FILE_LIST(FILE_LIST);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileList> CreateFileListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GameContent::File>> *FILE_LIST = nullptr,
    uint32_t LAST_ID = 0) {
  auto FILE_LIST__ = FILE_LIST ? _fbb.CreateVector<flatbuffers::Offset<GameContent::File>>(*FILE_LIST) : 0;
  return GameContent::CreateFileList(
      _fbb,
      FILE_LIST__,
      LAST_ID);
}

struct Resource FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_TYPE = 4,
    VT_TYPE = 6
  };
  GameContent::Resource_Type TYPE_type() const {
    return static_cast<GameContent::Resource_Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *TYPE() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *TYPE_as() const;
  const GameContent::MATERIAL_TYPE *TYPE_as_Material_Type() const {
    return TYPE_type() == GameContent::Resource_Type_Material_Type ? static_cast<const GameContent::MATERIAL_TYPE *>(TYPE()) : nullptr;
  }
  const GameContent::MATERIAL_INSTANCE *TYPE_as_Material_Instance() const {
    return TYPE_type() == GameContent::Resource_Type_Material_Instance ? static_cast<const GameContent::MATERIAL_INSTANCE *>(TYPE()) : nullptr;
  }
  const GameContent::TEXTURE *TYPE_as_Texture() const {
    return TYPE_type() == GameContent::Resource_Type_Texture ? static_cast<const GameContent::TEXTURE *>(TYPE()) : nullptr;
  }
  const GameContent::STATIC_MODEL *TYPE_as_Static_Model() const {
    return TYPE_type() == GameContent::Resource_Type_Static_Model ? static_cast<const GameContent::STATIC_MODEL *>(TYPE()) : nullptr;
  }
  const GameContent::SCENE *TYPE_as_Scene() const {
    return TYPE_type() == GameContent::Resource_Type_Scene ? static_cast<const GameContent::SCENE *>(TYPE()) : nullptr;
  }
  const GameContent::FileList *TYPE_as_File_List() const {
    return TYPE_type() == GameContent::Resource_Type_File_List ? static_cast<const GameContent::FileList *>(TYPE()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyResource_Type(verifier, TYPE(), TYPE_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GameContent::MATERIAL_TYPE *Resource::TYPE_as<GameContent::MATERIAL_TYPE>() const {
  return TYPE_as_Material_Type();
}

template<> inline const GameContent::MATERIAL_INSTANCE *Resource::TYPE_as<GameContent::MATERIAL_INSTANCE>() const {
  return TYPE_as_Material_Instance();
}

template<> inline const GameContent::TEXTURE *Resource::TYPE_as<GameContent::TEXTURE>() const {
  return TYPE_as_Texture();
}

template<> inline const GameContent::STATIC_MODEL *Resource::TYPE_as<GameContent::STATIC_MODEL>() const {
  return TYPE_as_Static_Model();
}

template<> inline const GameContent::SCENE *Resource::TYPE_as<GameContent::SCENE>() const {
  return TYPE_as_Scene();
}

template<> inline const GameContent::FileList *Resource::TYPE_as<GameContent::FileList>() const {
  return TYPE_as_File_List();
}

struct ResourceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TYPE_type(GameContent::Resource_Type TYPE_type) {
    fbb_.AddElement<uint8_t>(Resource::VT_TYPE_TYPE, static_cast<uint8_t>(TYPE_type), 0);
  }
  void add_TYPE(flatbuffers::Offset<void> TYPE) {
    fbb_.AddOffset(Resource::VT_TYPE, TYPE);
  }
  explicit ResourceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourceBuilder &operator=(const ResourceBuilder &);
  flatbuffers::Offset<Resource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resource>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resource> CreateResource(
    flatbuffers::FlatBufferBuilder &_fbb,
    GameContent::Resource_Type TYPE_type = GameContent::Resource_Type_NONE,
    flatbuffers::Offset<void> TYPE = 0) {
  ResourceBuilder builder_(_fbb);
  builder_.add_TYPE(TYPE);
  builder_.add_TYPE_type(TYPE_type);
  return builder_.Finish();
}

inline bool VerifyMATERIAL_INSTANCE_UNIFORM(flatbuffers::Verifier &verifier, const void *obj, MATERIAL_INSTANCE_UNIFORM type) {
  switch (type) {
    case MATERIAL_INSTANCE_UNIFORM_NONE: {
      return true;
    }
    case MATERIAL_INSTANCE_UNIFORM_UINT32: {
      auto ptr = reinterpret_cast<const GameContent::UNIFORM_UINT32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_INT32: {
      auto ptr = reinterpret_cast<const GameContent::UNIFORM_INT32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_FLOAT: {
      auto ptr = reinterpret_cast<const GameContent::UNIFORM_FLOAT *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_VEC2: {
      auto ptr = reinterpret_cast<const GameContent::UNIFORM_VEC2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_VEC3: {
      auto ptr = reinterpret_cast<const GameContent::UNIFORM_VEC3 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_VEC4: {
      auto ptr = reinterpret_cast<const GameContent::UNIFORM_VEC4 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_Mat4x4: {
      auto ptr = reinterpret_cast<const GameContent::UNIFORM_MAT4x4 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_TEXTURE2D: {
      auto ptr = reinterpret_cast<const GameContent::UNIFORM_TEXTURE2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMATERIAL_INSTANCE_UNIFORMVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMATERIAL_INSTANCE_UNIFORM(
        verifier,  values->Get(i), types->GetEnum<MATERIAL_INSTANCE_UNIFORM>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGameComponent_Type(flatbuffers::Verifier &verifier, const void *obj, GameComponent_Type type) {
  switch (type) {
    case GameComponent_Type_NONE: {
      return true;
    }
    case GameComponent_Type_StaticModel_Component: {
      auto ptr = reinterpret_cast<const GameContent::StaticModel_ComponentTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameComponent_Type_Camera_Component: {
      auto ptr = reinterpret_cast<const GameContent::Camera_ComponentTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyGameComponent_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGameComponent_Type(
        verifier,  values->Get(i), types->GetEnum<GameComponent_Type>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResource_Type(flatbuffers::Verifier &verifier, const void *obj, Resource_Type type) {
  switch (type) {
    case Resource_Type_NONE: {
      return true;
    }
    case Resource_Type_Material_Type: {
      auto ptr = reinterpret_cast<const GameContent::MATERIAL_TYPE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Material_Instance: {
      auto ptr = reinterpret_cast<const GameContent::MATERIAL_INSTANCE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Texture: {
      auto ptr = reinterpret_cast<const GameContent::TEXTURE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Static_Model: {
      auto ptr = reinterpret_cast<const GameContent::STATIC_MODEL *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Scene: {
      auto ptr = reinterpret_cast<const GameContent::SCENE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_File_List: {
      auto ptr = reinterpret_cast<const GameContent::FileList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResource_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResource_Type(
        verifier,  values->Get(i), types->GetEnum<Resource_Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const GameContent::Resource *GetResource(const void *buf) {
  return flatbuffers::GetRoot<GameContent::Resource>(buf);
}

inline const GameContent::Resource *GetSizePrefixedResource(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<GameContent::Resource>(buf);
}

inline bool VerifyResourceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GameContent::Resource>(nullptr);
}

inline bool VerifySizePrefixedResourceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GameContent::Resource>(nullptr);
}

inline void FinishResourceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GameContent::Resource> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResourceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GameContent::Resource> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace GameContent

#endif  // FLATBUFFERS_GENERATED_GAMERESOURCE_GAMECONTENT_H_
