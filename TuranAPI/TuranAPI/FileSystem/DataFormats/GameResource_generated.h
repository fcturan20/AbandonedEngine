// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAMERESOURCE_GAMECONTENT_H_
#define FLATBUFFERS_GENERATED_GAMERESOURCE_GAMECONTENT_H_

#include "flatbuffers/flatbuffers.h"

namespace GameContent {

struct Vec3;

struct Vec2;

struct TEXTURE;

struct MATERIAL_TYPE;

struct MATERIAL_INSTANCE;

struct MESH;

struct STATIC_MODEL;

struct SCENE;

struct Resource;

enum TEXTURE_TYPE {
  TEXTURE_TYPE_DIFFUSE_TEXTURE = 0,
  TEXTURE_TYPE_SPECULAR_TEXTURE = 1,
  TEXTURE_TYPE_NORMAL_TEXTURE = 2,
  TEXTURE_TYPE_MIN = TEXTURE_TYPE_DIFFUSE_TEXTURE,
  TEXTURE_TYPE_MAX = TEXTURE_TYPE_NORMAL_TEXTURE
};

inline const TEXTURE_TYPE (&EnumValuesTEXTURE_TYPE())[3] {
  static const TEXTURE_TYPE values[] = {
    TEXTURE_TYPE_DIFFUSE_TEXTURE,
    TEXTURE_TYPE_SPECULAR_TEXTURE,
    TEXTURE_TYPE_NORMAL_TEXTURE
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_TYPE() {
  static const char * const names[4] = {
    "DIFFUSE_TEXTURE",
    "SPECULAR_TEXTURE",
    "NORMAL_TEXTURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_TYPE(TEXTURE_TYPE e) {
  if (e < TEXTURE_TYPE_DIFFUSE_TEXTURE || e > TEXTURE_TYPE_NORMAL_TEXTURE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_TYPE()[index];
}

enum TEXTURE_CHANNELS {
  TEXTURE_CHANNELS_TEXTURE_RGB = 0,
  TEXTURE_CHANNELS_TEXTURE_RGBA = 1,
  TEXTURE_CHANNELS_TEXTURE_DEPTH = 2,
  TEXTURE_CHANNELS_MIN = TEXTURE_CHANNELS_TEXTURE_RGB,
  TEXTURE_CHANNELS_MAX = TEXTURE_CHANNELS_TEXTURE_DEPTH
};

inline const TEXTURE_CHANNELS (&EnumValuesTEXTURE_CHANNELS())[3] {
  static const TEXTURE_CHANNELS values[] = {
    TEXTURE_CHANNELS_TEXTURE_RGB,
    TEXTURE_CHANNELS_TEXTURE_RGBA,
    TEXTURE_CHANNELS_TEXTURE_DEPTH
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_CHANNELS() {
  static const char * const names[4] = {
    "TEXTURE_RGB",
    "TEXTURE_RGBA",
    "TEXTURE_DEPTH",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_CHANNELS(TEXTURE_CHANNELS e) {
  if (e < TEXTURE_CHANNELS_TEXTURE_RGB || e > TEXTURE_CHANNELS_TEXTURE_DEPTH) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_CHANNELS()[index];
}

enum GFX_APIs {
  GFX_APIs_OPENGL3 = 0,
  GFX_APIs_MIN = GFX_APIs_OPENGL3,
  GFX_APIs_MAX = GFX_APIs_OPENGL3
};

inline const GFX_APIs (&EnumValuesGFX_APIs())[1] {
  static const GFX_APIs values[] = {
    GFX_APIs_OPENGL3
  };
  return values;
}

inline const char * const *EnumNamesGFX_APIs() {
  static const char * const names[2] = {
    "OPENGL3",
    nullptr
  };
  return names;
}

inline const char *EnumNameGFX_APIs(GFX_APIs e) {
  if (e < GFX_APIs_OPENGL3 || e > GFX_APIs_OPENGL3) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGFX_APIs()[index];
}

enum Resource_Type {
  Resource_Type_NONE = 0,
  Resource_Type_Material_Type = 1,
  Resource_Type_Texture = 2,
  Resource_Type_Static_Model = 3,
  Resource_Type_Scene = 4,
  Resource_Type_MIN = Resource_Type_NONE,
  Resource_Type_MAX = Resource_Type_Scene
};

inline const Resource_Type (&EnumValuesResource_Type())[5] {
  static const Resource_Type values[] = {
    Resource_Type_NONE,
    Resource_Type_Material_Type,
    Resource_Type_Texture,
    Resource_Type_Static_Model,
    Resource_Type_Scene
  };
  return values;
}

inline const char * const *EnumNamesResource_Type() {
  static const char * const names[6] = {
    "NONE",
    "Material_Type",
    "Texture",
    "Static_Model",
    "Scene",
    nullptr
  };
  return names;
}

inline const char *EnumNameResource_Type(Resource_Type e) {
  if (e < Resource_Type_NONE || e > Resource_Type_Scene) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResource_Type()[index];
}

template<typename T> struct Resource_TypeTraits {
  static const Resource_Type enum_value = Resource_Type_NONE;
};

template<> struct Resource_TypeTraits<GameContent::MATERIAL_TYPE> {
  static const Resource_Type enum_value = Resource_Type_Material_Type;
};

template<> struct Resource_TypeTraits<GameContent::TEXTURE> {
  static const Resource_Type enum_value = Resource_Type_Texture;
};

template<> struct Resource_TypeTraits<GameContent::STATIC_MODEL> {
  static const Resource_Type enum_value = Resource_Type_Static_Model;
};

template<> struct Resource_TypeTraits<GameContent::SCENE> {
  static const Resource_Type enum_value = Resource_Type_Scene;
};

bool VerifyResource_Type(flatbuffers::Verifier &verifier, const void *obj, Resource_Type type);
bool VerifyResource_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

struct TEXTURE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_CHANNELS = 6
  };
  GameContent::TEXTURE_TYPE TYPE() const {
    return static_cast<GameContent::TEXTURE_TYPE>(GetField<uint8_t>(VT_TYPE, 0));
  }
  GameContent::TEXTURE_CHANNELS CHANNELS() const {
    return static_cast<GameContent::TEXTURE_CHANNELS>(GetField<uint8_t>(VT_CHANNELS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELS) &&
           verifier.EndTable();
  }
};

struct TEXTUREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TYPE(GameContent::TEXTURE_TYPE TYPE) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_TYPE, static_cast<uint8_t>(TYPE), 0);
  }
  void add_CHANNELS(GameContent::TEXTURE_CHANNELS CHANNELS) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_CHANNELS, static_cast<uint8_t>(CHANNELS), 0);
  }
  explicit TEXTUREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TEXTUREBuilder &operator=(const TEXTUREBuilder &);
  flatbuffers::Offset<TEXTURE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TEXTURE>(end);
    return o;
  }
};

inline flatbuffers::Offset<TEXTURE> CreateTEXTURE(
    flatbuffers::FlatBufferBuilder &_fbb,
    GameContent::TEXTURE_TYPE TYPE = GameContent::TEXTURE_TYPE_DIFFUSE_TEXTURE,
    GameContent::TEXTURE_CHANNELS CHANNELS = GameContent::TEXTURE_CHANNELS_TEXTURE_RGB) {
  TEXTUREBuilder builder_(_fbb);
  builder_.add_CHANNELS(CHANNELS);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

struct MATERIAL_TYPE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GFX_API = 4,
    VT_VERTEX_SHADER = 6,
    VT_FRAGMENT_SHADER = 8
  };
  GameContent::GFX_APIs GFX_API() const {
    return static_cast<GameContent::GFX_APIs>(GetField<uint8_t>(VT_GFX_API, 0));
  }
  const flatbuffers::String *VERTEX_SHADER() const {
    return GetPointer<const flatbuffers::String *>(VT_VERTEX_SHADER);
  }
  const flatbuffers::String *FRAGMENT_SHADER() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAGMENT_SHADER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GFX_API) &&
           VerifyOffset(verifier, VT_VERTEX_SHADER) &&
           verifier.VerifyString(VERTEX_SHADER()) &&
           VerifyOffset(verifier, VT_FRAGMENT_SHADER) &&
           verifier.VerifyString(FRAGMENT_SHADER()) &&
           verifier.EndTable();
  }
};

struct MATERIAL_TYPEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GFX_API(GameContent::GFX_APIs GFX_API) {
    fbb_.AddElement<uint8_t>(MATERIAL_TYPE::VT_GFX_API, static_cast<uint8_t>(GFX_API), 0);
  }
  void add_VERTEX_SHADER(flatbuffers::Offset<flatbuffers::String> VERTEX_SHADER) {
    fbb_.AddOffset(MATERIAL_TYPE::VT_VERTEX_SHADER, VERTEX_SHADER);
  }
  void add_FRAGMENT_SHADER(flatbuffers::Offset<flatbuffers::String> FRAGMENT_SHADER) {
    fbb_.AddOffset(MATERIAL_TYPE::VT_FRAGMENT_SHADER, FRAGMENT_SHADER);
  }
  explicit MATERIAL_TYPEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MATERIAL_TYPEBuilder &operator=(const MATERIAL_TYPEBuilder &);
  flatbuffers::Offset<MATERIAL_TYPE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MATERIAL_TYPE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MATERIAL_TYPE> CreateMATERIAL_TYPE(
    flatbuffers::FlatBufferBuilder &_fbb,
    GameContent::GFX_APIs GFX_API = GameContent::GFX_APIs_OPENGL3,
    flatbuffers::Offset<flatbuffers::String> VERTEX_SHADER = 0,
    flatbuffers::Offset<flatbuffers::String> FRAGMENT_SHADER = 0) {
  MATERIAL_TYPEBuilder builder_(_fbb);
  builder_.add_FRAGMENT_SHADER(FRAGMENT_SHADER);
  builder_.add_VERTEX_SHADER(VERTEX_SHADER);
  builder_.add_GFX_API(GFX_API);
  return builder_.Finish();
}

inline flatbuffers::Offset<MATERIAL_TYPE> CreateMATERIAL_TYPEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GameContent::GFX_APIs GFX_API = GameContent::GFX_APIs_OPENGL3,
    const char *VERTEX_SHADER = nullptr,
    const char *FRAGMENT_SHADER = nullptr) {
  auto VERTEX_SHADER__ = VERTEX_SHADER ? _fbb.CreateString(VERTEX_SHADER) : 0;
  auto FRAGMENT_SHADER__ = FRAGMENT_SHADER ? _fbb.CreateString(FRAGMENT_SHADER) : 0;
  return GameContent::CreateMATERIAL_TYPE(
      _fbb,
      GFX_API,
      VERTEX_SHADER__,
      FRAGMENT_SHADER__);
}

struct MATERIAL_INSTANCE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL_TYPE_ID = 4,
    VT_TEXTURES = 6
  };
  uint16_t MATERIAL_TYPE_ID() const {
    return GetField<uint16_t>(VT_MATERIAL_TYPE_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GameContent::TEXTURE>> *TEXTUREs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameContent::TEXTURE>> *>(VT_TEXTURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MATERIAL_TYPE_ID) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(TEXTUREs()) &&
           verifier.VerifyVectorOfTables(TEXTUREs()) &&
           verifier.EndTable();
  }
};

struct MATERIAL_INSTANCEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MATERIAL_TYPE_ID(uint16_t MATERIAL_TYPE_ID) {
    fbb_.AddElement<uint16_t>(MATERIAL_INSTANCE::VT_MATERIAL_TYPE_ID, MATERIAL_TYPE_ID, 0);
  }
  void add_TEXTUREs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::TEXTURE>>> TEXTUREs) {
    fbb_.AddOffset(MATERIAL_INSTANCE::VT_TEXTURES, TEXTUREs);
  }
  explicit MATERIAL_INSTANCEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MATERIAL_INSTANCEBuilder &operator=(const MATERIAL_INSTANCEBuilder &);
  flatbuffers::Offset<MATERIAL_INSTANCE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MATERIAL_INSTANCE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MATERIAL_INSTANCE> CreateMATERIAL_INSTANCE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t MATERIAL_TYPE_ID = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::TEXTURE>>> TEXTUREs = 0) {
  MATERIAL_INSTANCEBuilder builder_(_fbb);
  builder_.add_TEXTUREs(TEXTUREs);
  builder_.add_MATERIAL_TYPE_ID(MATERIAL_TYPE_ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<MATERIAL_INSTANCE> CreateMATERIAL_INSTANCEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t MATERIAL_TYPE_ID = 0,
    const std::vector<flatbuffers::Offset<GameContent::TEXTURE>> *TEXTUREs = nullptr) {
  auto TEXTUREs__ = TEXTUREs ? _fbb.CreateVector<flatbuffers::Offset<GameContent::TEXTURE>>(*TEXTUREs) : 0;
  return GameContent::CreateMATERIAL_INSTANCE(
      _fbb,
      MATERIAL_TYPE_ID,
      TEXTUREs__);
}

struct MESH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITIONS = 4,
    VT_TEXTCOORDS = 6,
    VT_NORMALS = 8,
    VT_TANGENTS = 10,
    VT_BITANGENTS = 12,
    VT_INDICES = 14,
    VT_MATERIAL_INDEX = 16
  };
  const flatbuffers::Vector<const GameContent::Vec3 *> *Positions() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec3 *> *>(VT_POSITIONS);
  }
  const flatbuffers::Vector<const GameContent::Vec2 *> *TextCoords() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec2 *> *>(VT_TEXTCOORDS);
  }
  const flatbuffers::Vector<const GameContent::Vec3 *> *Normals() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec3 *> *>(VT_NORMALS);
  }
  const flatbuffers::Vector<const GameContent::Vec3 *> *Tangents() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec3 *> *>(VT_TANGENTS);
  }
  const flatbuffers::Vector<const GameContent::Vec3 *> *Bitangents() const {
    return GetPointer<const flatbuffers::Vector<const GameContent::Vec3 *> *>(VT_BITANGENTS);
  }
  const flatbuffers::Vector<uint32_t> *Indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INDICES);
  }
  uint32_t Material_Index() const {
    return GetField<uint32_t>(VT_MATERIAL_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(Positions()) &&
           VerifyOffset(verifier, VT_TEXTCOORDS) &&
           verifier.VerifyVector(TextCoords()) &&
           VerifyOffset(verifier, VT_NORMALS) &&
           verifier.VerifyVector(Normals()) &&
           VerifyOffset(verifier, VT_TANGENTS) &&
           verifier.VerifyVector(Tangents()) &&
           VerifyOffset(verifier, VT_BITANGENTS) &&
           verifier.VerifyVector(Bitangents()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(Indices()) &&
           VerifyField<uint32_t>(verifier, VT_MATERIAL_INDEX) &&
           verifier.EndTable();
  }
};

struct MESHBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Positions(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Positions) {
    fbb_.AddOffset(MESH::VT_POSITIONS, Positions);
  }
  void add_TextCoords(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec2 *>> TextCoords) {
    fbb_.AddOffset(MESH::VT_TEXTCOORDS, TextCoords);
  }
  void add_Normals(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Normals) {
    fbb_.AddOffset(MESH::VT_NORMALS, Normals);
  }
  void add_Tangents(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Tangents) {
    fbb_.AddOffset(MESH::VT_TANGENTS, Tangents);
  }
  void add_Bitangents(flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Bitangents) {
    fbb_.AddOffset(MESH::VT_BITANGENTS, Bitangents);
  }
  void add_Indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> Indices) {
    fbb_.AddOffset(MESH::VT_INDICES, Indices);
  }
  void add_Material_Index(uint32_t Material_Index) {
    fbb_.AddElement<uint32_t>(MESH::VT_MATERIAL_INDEX, Material_Index, 0);
  }
  explicit MESHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MESHBuilder &operator=(const MESHBuilder &);
  flatbuffers::Offset<MESH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MESH>(end);
    return o;
  }
};

inline flatbuffers::Offset<MESH> CreateMESH(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec2 *>> TextCoords = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Normals = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Tangents = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GameContent::Vec3 *>> Bitangents = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> Indices = 0,
    uint32_t Material_Index = 0) {
  MESHBuilder builder_(_fbb);
  builder_.add_Material_Index(Material_Index);
  builder_.add_Indices(Indices);
  builder_.add_Bitangents(Bitangents);
  builder_.add_Tangents(Tangents);
  builder_.add_Normals(Normals);
  builder_.add_TextCoords(TextCoords);
  builder_.add_Positions(Positions);
  return builder_.Finish();
}

inline flatbuffers::Offset<MESH> CreateMESHDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<GameContent::Vec3> *Positions = nullptr,
    const std::vector<GameContent::Vec2> *TextCoords = nullptr,
    const std::vector<GameContent::Vec3> *Normals = nullptr,
    const std::vector<GameContent::Vec3> *Tangents = nullptr,
    const std::vector<GameContent::Vec3> *Bitangents = nullptr,
    const std::vector<uint32_t> *Indices = nullptr,
    uint32_t Material_Index = 0) {
  auto Positions__ = Positions ? _fbb.CreateVectorOfStructs<GameContent::Vec3>(*Positions) : 0;
  auto TextCoords__ = TextCoords ? _fbb.CreateVectorOfStructs<GameContent::Vec2>(*TextCoords) : 0;
  auto Normals__ = Normals ? _fbb.CreateVectorOfStructs<GameContent::Vec3>(*Normals) : 0;
  auto Tangents__ = Tangents ? _fbb.CreateVectorOfStructs<GameContent::Vec3>(*Tangents) : 0;
  auto Bitangents__ = Bitangents ? _fbb.CreateVectorOfStructs<GameContent::Vec3>(*Bitangents) : 0;
  auto Indices__ = Indices ? _fbb.CreateVector<uint32_t>(*Indices) : 0;
  return GameContent::CreateMESH(
      _fbb,
      Positions__,
      TextCoords__,
      Normals__,
      Tangents__,
      Bitangents__,
      Indices__,
      Material_Index);
}

struct STATIC_MODEL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESHES = 4,
    VT_MATERIALS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<GameContent::MESH>> *MESHes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameContent::MESH>> *>(VT_MESHES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE>> *MATERIALs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE>> *>(VT_MATERIALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(MESHes()) &&
           verifier.VerifyVectorOfTables(MESHes()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(MATERIALs()) &&
           verifier.VerifyVectorOfTables(MATERIALs()) &&
           verifier.EndTable();
  }
};

struct STATIC_MODELBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MESHes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MESH>>> MESHes) {
    fbb_.AddOffset(STATIC_MODEL::VT_MESHES, MESHes);
  }
  void add_MATERIALs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE>>> MATERIALs) {
    fbb_.AddOffset(STATIC_MODEL::VT_MATERIALS, MATERIALs);
  }
  explicit STATIC_MODELBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  STATIC_MODELBuilder &operator=(const STATIC_MODELBuilder &);
  flatbuffers::Offset<STATIC_MODEL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<STATIC_MODEL>(end);
    return o;
  }
};

inline flatbuffers::Offset<STATIC_MODEL> CreateSTATIC_MODEL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MESH>>> MESHes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE>>> MATERIALs = 0) {
  STATIC_MODELBuilder builder_(_fbb);
  builder_.add_MATERIALs(MATERIALs);
  builder_.add_MESHes(MESHes);
  return builder_.Finish();
}

inline flatbuffers::Offset<STATIC_MODEL> CreateSTATIC_MODELDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GameContent::MESH>> *MESHes = nullptr,
    const std::vector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE>> *MATERIALs = nullptr) {
  auto MESHes__ = MESHes ? _fbb.CreateVector<flatbuffers::Offset<GameContent::MESH>>(*MESHes) : 0;
  auto MATERIALs__ = MATERIALs ? _fbb.CreateVector<flatbuffers::Offset<GameContent::MATERIAL_INSTANCE>>(*MATERIALs) : 0;
  return GameContent::CreateSTATIC_MODEL(
      _fbb,
      MESHes__,
      MATERIALs__);
}

struct SCENE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           verifier.EndTable();
  }
};

struct SCENEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(SCENE::VT_NAME, NAME);
  }
  explicit SCENEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SCENEBuilder &operator=(const SCENEBuilder &);
  flatbuffers::Offset<SCENE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SCENE>(end);
    return o;
  }
};

inline flatbuffers::Offset<SCENE> CreateSCENE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0) {
  SCENEBuilder builder_(_fbb);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<SCENE> CreateSCENEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GameContent::CreateSCENE(
      _fbb,
      NAME__);
}

struct Resource FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_TYPE = 4,
    VT_TYPE = 6
  };
  GameContent::Resource_Type TYPE_type() const {
    return static_cast<GameContent::Resource_Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *TYPE() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *TYPE_as() const;
  const GameContent::MATERIAL_TYPE *TYPE_as_Material_Type() const {
    return static_cast<const GameContent::MATERIAL_TYPE *>(TYPE());
  }
  const GameContent::TEXTURE *TYPE_as_Texture() const {
    return static_cast<const GameContent::TEXTURE *>(TYPE());
  }
  const GameContent::STATIC_MODEL *TYPE_as_Static_Model() const {
    return static_cast<const GameContent::STATIC_MODEL *>(TYPE());
  }
  const GameContent::SCENE *TYPE_as_Scene() const {
    return static_cast<const GameContent::SCENE *>(TYPE());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyResource_Type(verifier, TYPE(), TYPE_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GameContent::MATERIAL_TYPE *Resource::TYPE_as<GameContent::MATERIAL_TYPE>() const {
  return TYPE_as_Material_Type();
}

template<> inline const GameContent::TEXTURE *Resource::TYPE_as<GameContent::TEXTURE>() const {
  return TYPE_as_Texture();
}

template<> inline const GameContent::STATIC_MODEL *Resource::TYPE_as<GameContent::STATIC_MODEL>() const {
  return TYPE_as_Static_Model();
}

template<> inline const GameContent::SCENE *Resource::TYPE_as<GameContent::SCENE>() const {
  return TYPE_as_Scene();
}

struct ResourceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TYPE_type(GameContent::Resource_Type TYPE_type) {
    fbb_.AddElement<uint8_t>(Resource::VT_TYPE_TYPE, static_cast<uint8_t>(TYPE_type), 0);
  }
  void add_TYPE(flatbuffers::Offset<void> TYPE) {
    fbb_.AddOffset(Resource::VT_TYPE, TYPE);
  }
  explicit ResourceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourceBuilder &operator=(const ResourceBuilder &);
  flatbuffers::Offset<Resource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resource>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resource> CreateResource(
    flatbuffers::FlatBufferBuilder &_fbb,
    GameContent::Resource_Type TYPE_type = GameContent::Resource_Type_NONE,
    flatbuffers::Offset<void> TYPE = 0) {
  ResourceBuilder builder_(_fbb);
  builder_.add_TYPE(TYPE);
  builder_.add_TYPE_type(TYPE_type);
  return builder_.Finish();
}

inline bool VerifyResource_Type(flatbuffers::Verifier &verifier, const void *obj, Resource_Type type) {
  switch (type) {
    case Resource_Type_NONE: {
      return true;
    }
    case Resource_Type_Material_Type: {
      auto ptr = reinterpret_cast<const GameContent::MATERIAL_TYPE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Texture: {
      auto ptr = reinterpret_cast<const GameContent::TEXTURE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Static_Model: {
      auto ptr = reinterpret_cast<const GameContent::STATIC_MODEL *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Scene: {
      auto ptr = reinterpret_cast<const GameContent::SCENE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResource_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResource_Type(
        verifier,  values->Get(i), types->GetEnum<Resource_Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const GameContent::Resource *GetResource(const void *buf) {
  return flatbuffers::GetRoot<GameContent::Resource>(buf);
}

inline const GameContent::Resource *GetSizePrefixedResource(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<GameContent::Resource>(buf);
}

inline bool VerifyResourceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GameContent::Resource>(nullptr);
}

inline bool VerifySizePrefixedResourceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GameContent::Resource>(nullptr);
}

inline void FinishResourceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GameContent::Resource> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResourceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GameContent::Resource> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace GameContent

#endif  // FLATBUFFERS_GENERATED_GAMERESOURCE_GAMECONTENT_H_
