// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FILELIST_EDITOR_FILELIST_H_
#define FLATBUFFERS_GENERATED_FILELIST_EDITOR_FILELIST_H_

#include "flatbuffers/flatbuffers.h"

namespace Editor {
namespace FileList {

struct File;

struct FileList;

enum File_Type {
  File_Type_ERROR = 0,
  File_Type_Camera = 1,
  File_Type_Static_Model = 2,
  File_Type_Scene = 3,
  File_Type_MIN = File_Type_ERROR,
  File_Type_MAX = File_Type_Scene
};

inline const File_Type (&EnumValuesFile_Type())[4] {
  static const File_Type values[] = {
    File_Type_ERROR,
    File_Type_Camera,
    File_Type_Static_Model,
    File_Type_Scene
  };
  return values;
}

inline const char * const *EnumNamesFile_Type() {
  static const char * const names[5] = {
    "ERROR",
    "Camera",
    "Static_Model",
    "Scene",
    nullptr
  };
  return names;
}

inline const char *EnumNameFile_Type(File_Type e) {
  if (e < File_Type_ERROR || e > File_Type_Scene) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFile_Type()[index];
}

struct File FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_TYPE = 6,
    VT_ID = 8
  };
  const flatbuffers::String *PATH() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  Editor::FileList::File_Type TYPE() const {
    return static_cast<Editor::FileList::File_Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint32_t ID() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(PATH()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct FileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PATH(flatbuffers::Offset<flatbuffers::String> PATH) {
    fbb_.AddOffset(File::VT_PATH, PATH);
  }
  void add_TYPE(Editor::FileList::File_Type TYPE) {
    fbb_.AddElement<uint8_t>(File::VT_TYPE, static_cast<uint8_t>(TYPE), 0);
  }
  void add_ID(uint32_t ID) {
    fbb_.AddElement<uint32_t>(File::VT_ID, ID, 0);
  }
  explicit FileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileBuilder &operator=(const FileBuilder &);
  flatbuffers::Offset<File> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<File>(end);
    return o;
  }
};

inline flatbuffers::Offset<File> CreateFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> PATH = 0,
    Editor::FileList::File_Type TYPE = Editor::FileList::File_Type_ERROR,
    uint32_t ID = 0) {
  FileBuilder builder_(_fbb);
  builder_.add_ID(ID);
  builder_.add_PATH(PATH);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline flatbuffers::Offset<File> CreateFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *PATH = nullptr,
    Editor::FileList::File_Type TYPE = Editor::FileList::File_Type_ERROR,
    uint32_t ID = 0) {
  auto PATH__ = PATH ? _fbb.CreateString(PATH) : 0;
  return Editor::FileList::CreateFile(
      _fbb,
      PATH__,
      TYPE,
      ID);
}

struct FileList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_LIST = 4,
    VT_LAST_ID = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Editor::FileList::File>> *FILE_LIST() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Editor::FileList::File>> *>(VT_FILE_LIST);
  }
  uint32_t LAST_ID() const {
    return GetField<uint32_t>(VT_LAST_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE_LIST) &&
           verifier.VerifyVector(FILE_LIST()) &&
           verifier.VerifyVectorOfTables(FILE_LIST()) &&
           VerifyField<uint32_t>(verifier, VT_LAST_ID) &&
           verifier.EndTable();
  }
};

struct FileListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FILE_LIST(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Editor::FileList::File>>> FILE_LIST) {
    fbb_.AddOffset(FileList::VT_FILE_LIST, FILE_LIST);
  }
  void add_LAST_ID(uint32_t LAST_ID) {
    fbb_.AddElement<uint32_t>(FileList::VT_LAST_ID, LAST_ID, 0);
  }
  explicit FileListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileListBuilder &operator=(const FileListBuilder &);
  flatbuffers::Offset<FileList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileList>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileList> CreateFileList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Editor::FileList::File>>> FILE_LIST = 0,
    uint32_t LAST_ID = 0) {
  FileListBuilder builder_(_fbb);
  builder_.add_LAST_ID(LAST_ID);
  builder_.add_FILE_LIST(FILE_LIST);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileList> CreateFileListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Editor::FileList::File>> *FILE_LIST = nullptr,
    uint32_t LAST_ID = 0) {
  auto FILE_LIST__ = FILE_LIST ? _fbb.CreateVector<flatbuffers::Offset<Editor::FileList::File>>(*FILE_LIST) : 0;
  return Editor::FileList::CreateFileList(
      _fbb,
      FILE_LIST__,
      LAST_ID);
}

inline const Editor::FileList::FileList *GetFileList(const void *buf) {
  return flatbuffers::GetRoot<Editor::FileList::FileList>(buf);
}

inline const Editor::FileList::FileList *GetSizePrefixedFileList(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Editor::FileList::FileList>(buf);
}

inline bool VerifyFileListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Editor::FileList::FileList>(nullptr);
}

inline bool VerifySizePrefixedFileListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Editor::FileList::FileList>(nullptr);
}

inline void FinishFileListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Editor::FileList::FileList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFileListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Editor::FileList::FileList> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FileList
}  // namespace Editor

#endif  // FLATBUFFERS_GENERATED_FILELIST_EDITOR_FILELIST_H_
